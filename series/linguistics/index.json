[{"content":"This blog contains a detailed analysis of codemixing done by Me and my teammates Tanishq Chaudhary and Mayank Goel. We have used a Hindi-English dataset, and a more in-depth analysis + datasets can be found here.\nüßë Why Manual Annotations ? Simply because there did not exist any reliable tool which could do the task we wanted to do. Some of the common problems faced were due to:\n Tools not able to recognise latinised language: Example: \u0026lsquo;hey ram!\u0026rsquo;, here though \u0026lsquo;hey\u0026rsquo; is a valid English word, and we could probably make a case for greeting a person called ram, but Hindi speakers would know that this is an exclamation. Identifying Junctures: Since they are not able to aptly identify language, it becomes even more difficult for any tool to recognise the juncture or point where the language switch happens. Marking Features: We did not know what to look for, hence it would have been impossible to tell any tool to look for anything. We had to learn by going through all the sentences, and this allowed us to observe things we wouldn\u0026rsquo;t have been able to otherwise.  We have manually tagged 130ÓÇù sentences with the above features, and deeply analysed another 100 sentences.\nüìã Introduction We have taken ~600 sentences of Hindi-English code mixed twitter data. We took care of not to clean it, since cleaning might remove or edit the context which allows us to make a decision whether the word/clause is in Hindi or English. Each sentence was divided into 3 base categories:\n All English (AE): Tweets which were written in pure English All Hindi (AH): Tweets which were written in pure Hindi Code Switch (CS): Tweets which had words of both Hindi and English  After this, we went through and deeply analysed 100 CS sentences to identify some key features which gave us insights towards the rules used in code-mixed\nlanguages. Once we got these rules, we marked all the sentences with those features wherever we could observe them. This gave us both a qualitative and quantitative bases about code-mixed languages and the features which exist in it.\nüì¶ Matrix and Embedding Matrix is the primary language of the sentence (tweet) on which the secondary language is embedded. In our dataset, we observed that Hindi was the matrix in\nmost sentences, with English being embedded in it. Another point that leads to this conclusion is the sheer number of AH sentences as compared to AE tweets\n ‚úîÔ∏è Features üîÑ Word Swap Word Swap refers to the sentences mostly in a single language but has 2-3 words in the embedded language. This was one of the most observed features, and we\nhave found a lot of insights using this.\n In most cases we observed that one or two English words were being used in Hindi Language In some cases, a specific pattern was seen with Word Swap, where adjectives were often used in English in Hindi sentences A few word swaps were used as a case of using borrowed words from English in Hindi sentences.  Noun Phrase: We also observed some number of instances where the compound word, or a noun phrase was swapped. This is when we have the matrix language\nas Hindi.\nExamples:\n Sab anti national hai saale. @lack_a_daisy @Being_Humor bhai minus one point tujhe Chalo ab koi sting operation karke kisi sarkar ko nanga nahi kar sakti \u0026hellip; maare jaoge #RightToPrivacy @kamaalrkhan sir ye tweet unko bhej do. Itni Hi-Fi English padh ke wo waise hi suicide kar lega  Reverse Word Swap: An instance of Word Swap, where we expect a word to be used in a particular language, but the speaker uses it in a different language. We observe that for Hindi as matrix language, we would see someone using more common English words, but the opposite happens\nExamples:\n tumhare chashme ka number hai kya? Chalo ab koi sting operation karke kisi sarkar ko nanga nahi kar sakti \u0026hellip;maare jaoge #RightToPrivacy Desh ka yuva jaag chuka hai, yuvika ka kya?  üîå Code Switching There were numerous instances of code switching that took place, which had complete all Hindi and all English sentences, bundled together:\n @MeetUunngLee bhai tu mil raha hai weekend. Thats it @himanshujainon @DrGarekar @ashvasant are bhai uski biwi ne mana kia tha. He is innocent otherwise like # kanhaiya , poor student of #JNU #GST is The new Duckworth Lewis method. Jo Aaj Tak Kisi ko samjh nhi aaya Grow up Bharkha \u0026hellip; It\u0026rsquo;s too much now. Bharat mai kahi shaktiman hai joo aaj bhi problem mai hai \u0026hellip; Whaha Jaa kar aao Jeet ka jashn aur shubah ki shuruat by eating bread pakoda at Tandon\u0026rsquo;s Cottage Vaishali Damoh  ‚úåÔ∏è Quotes In cases, we observed that the sentence would be in English or Hindi, as the matrix language, and there would be a Hindi sentence in quotes. That hindi\nsentence itself can show other phenomena like word swapping, which is explained above.\n #RailBudget2015 #PrabhuKiRail \u0026ldquo;Prabhu der aaye par durust aaye\u0026rdquo;. This budget is a revolution in Modern Indian Railways. \u0026quot; munh khol ke 20 rupay mang liye \u0026hellip;\u0026ldquo;oh i love this line . Thank God they didn\u0026rsquo;t end up with \u0026ldquo;Dekhna na bhooliye Ae Dil Hai Mushkil apni nasdeeki cinema gharon mein‚Äù. #MadeByGoogle From \u0026ldquo;azaadi hi meri Dulhan hai\u0026rdquo; to \u0026ldquo;Mera toh kaam hi mera valentine hai‚Äù @shubhansh1504 jab koi bahana nahi hota to bolte hai \u0026lsquo;server down hai\u0026rsquo;  Also note in the above, we have ‚Äúserver down‚Äù as a NP in a Hindi quotation in a Hindi sentence. These rules can be thus combined.\nüë™ Kinship Terms Kinship terms refer to the words with which a speaker refers to their kin or family. It was observed in codemixed sentences that speakers used kinship terms in the matrix language (which was Hindi in most cases)\n Happy Birthday Dhoni \u0026amp; Hello to Sakshi bhabhi. Aur baaki sab khairiyat? : Here bhabhi is used to refer to Sakshi, which is a Hindi kinship term. Bhai kuch kal ke liye bhi chhod de.. I hope that India wins the World Cup : Here bhai is used which is a Hindi Kinship term Everyone on TL is thanking their Moms.. Bhai aiyaashi karne ke paise to Papa hi dete hai na.. #ThankYouPapa: Here both English and Hindi kinship terms are used in respective clauses. This may seem contasting to the first sentence, but it is not so since it is observed that Greetings are often said in English (which is the case in the first sentence) RG : Mom mujhe budget budget khelna hai Mom : Beta , tumhare women empowerment khelneke din hai RG : yaay ! ringa ringa roses #RahulOnLeave :\nThis is an interesting example since both Hindi and English kinship terms are being used. Here, since we know who the sentence is about, we can draw\nmore inferences. Here RG uses English kinship to signify that he is more comfortable using that words, which can be seen with \u0026lsquo;ringa ringa roses\u0026rsquo; as\nwell. Contrastingly, the mother uses \u0026lsquo;beta\u0026rsquo;, hindi kinship term, since the sentence she speaks is in Hindi.   üíñ Romance When trying to express romantic feelings, oftentimes people end up embedding English words in Hindi sentences, or use purely english sentences\n ultimate yarrr . . . . just love it Bahut log hai jo aapse baat karna chahte hai..plzzzzzz dn\u0026rsquo;t brk thr hearts sir plzzzz @huh_watnow darling tumhara kuch ni ho sakta  ‚ú® Adjectives Oftentimes in Hindi adjectives of English are embedded to show stronger appreciation or disgust. Sometimes they appear as clauses as well.\n ultimate yarrr . . . . just love it jabatdast dost . . . . 1 page me rula diya yaar . . . . . kamaal hai . . . . superb nd hatss off to ur crearivity . . . @Dipti1104 bahut bold hain aap  üîÄ Noun-Adjective Order We observed that the data was overwhelmingly Adjective-Noun order, and the instances of Noun-Adjective are rare, for example in our manual annotation of\n130+ sentences, we observed only two such instances:\n Tu jo dariya mein utre saara paani gulaabi @ashutosh83B to phir rishta pakka samjhen?  Most of the cases had Adjective Noun ordering\n it is one of the best gigs of grbg bin i hv evr encontrd \u0026hellip;. smply owsm har cheez ka galat matlab nikal kar ye, galat shalat smmileys bhejti hai. Mujhe @Olacabs ne nahi bataya! Ye sarasar na insaafi hai chikna bhai   üëâ Relative Clause In some sentences with a main clause and relative clauses we observe that the transition is marked by Hindi words like ‚Äòjinke‚Äô, ‚Äòjisey‚Äô or English words like ‚Äòthat‚Äô.\n RT @ruchikokcha : @Atheist_Krishna Isiliye ( sadly ) I am perhaps the only woman jisey Kohli ko khelta dekh bhai wali feeling aati hai . #saynotocorruption #timetochange say no to dummies jinke pass khud ka dimaag nahi dusro k kahne par chalte hai #MakeInIndia @razonater @QararaRasha Sindh is not a property of Pakistan . The philosophy is that aap apna Sindh kahin bhi abaad kar sakte hen .  üè¢ Higher Institutions People often end up using the words in the same way that a higher institution has used it since it has become a norm.\n Please follow @SaleemChikna \u0026amp; @sayshardik, ye log free mein daaru pilaate hai. #AaiShappath aur free wifi bhi wahi hai. Lol @narendramodi @arunjaitley \u0026ldquo;Sir #GST rate cut ka fayda Consumer ko nahi mil raha \u0026ldquo;hai trader base price up karke usi price par bechta hai  üôè Respect and Greetings We also observed some amount of respect and greeting words being used. Most of them were in English, and would be sir/maam or cases where only the first\nword, the greeting would be in English and the rest of the sentence would be all Hindi\n okay sir. humare bhi din aayenge @kamaalrkhan sir ye tweet unko bhej do. Itni Hi-Fi English padh ke wo waise hi suicide kar lega.  Note how the second tweet here has only the first word English, which is respect word.\nüíº Case-Markers English does not have explicit case markers, hence it is observed that in sentences which start in English, Hindi case markers are used which often then\ncontinues as a Hindi sentence\n note ye application google playstore se download hogi , toh fake toh ho hi nahi sakti Phone ka wallpaper dekhte dekhte zindagi kat rahi hai.  üìú Rules Find the junctures of where the language switches can be difficult, so we instead re-frame the problem. What are the rules for generating code-mixed data? Once we have solved this problem we could move on to the original problem.\n For a tweet, select some sentences to be pure Hindi and some to be pure English. Hindi: Now, we swap out low frequency noun-phrases - could be 2 to 4 words, and we also swap low frequency Hindi words. This covers most of the cases\nobserved. We use the following features:  Kinship terms Adjectives Higher Institutions Respect   English: If the sentence includes some form of quotation, swap the quotation with pure Hindi. Then, use the rules for Hindi, taking the quotation as a\nsentence in itself. This covers:  Quotes Relative clause   Append any of \u0026ldquo;pls/plz/please\u0026rdquo; at the end, where the sentence is a request. If at the end we have a Hindi adjective and noun, in that order, then with a very low probability flip the order. Hindi will allow this (at least in cases that we observed). ","description":"A detailed description of types of codemixing in Hindi-English dataset.","id":0,"section":"posts","tags":["codemix"],"title":"Code-Mixing","uri":"https://aurumnpegasus.github.io/website/posts/codemix/"},{"content":"This blog talks about the structure of OSI model, and how data is sent across computers.\nüè∞ OSI Model The OSI Model (Open Systems Interconnection Model) is a conceptual framework used to describe the functions of a networking system. It defines rules and requirements that support effortless data transfer between different products and software. In the OSI reference model, the communications between a computing system are split into seven different abstraction layers: Physical, Data Link, Network, Transport, Session, Presentation, and Application.\n üß≠ Application The Application layer is the OSI layer closest to the end-user. In this layer, the user connects to the network via software that uses the internet, like Chrome, Firefox, MS Suite. It is important to note that these applications do not reside within the application layer. Instead, the application layer defines protocols (or rules) for the functioning of these applications.\nSome examples of the protocols defined are:\n FTP: Used for file transfers HTTP/S: Used for web surfing SMTP: Used for emails Telnet: Used for virtual terminal.  When data is given to the Application layer, it is passed down into the Presentation layer.\nüìë Presentation The Presentation layer receives data from the Application layer and converts it into machine language. It has three main tasks:\n Conversion: Converts the machine-specific data from the Application layer into a standardised format that the application layer could understand in the receiving computer. Compression: Often, the binary code after conversion is too large. It is then compressed to reduce the memory it takes. Encryption: As an additional layer of security, the compressed data is then encrypted using SSL (Secure Sockets Layer).  After these three tasks are done, the data is then transmitted to the Session layer. \\\n‚òéÔ∏è Session The Session layer controls the conversations between different computers. On receiving the data, it looks to connect with the other computer across the network. If it can not be done, then it returns an error message. If a session can be established, the Session layer is in charge of maintaining it. The Session layer also needs to co-operate with the Session layer of the other computer to synchronise communications. Once communication is over, the Session layer terminates the connection as well.\nThe Session layer creates unique sessions per communication request, due to which you can make multiple requests to different endpoints simultaneously (multiple tabs on a browser).\nOnce we get the data from the network, it is converted into data packets and sent to the Transport layer.\nüöö Transport The Transport layer receives data packets from the Session layer and chooses the protocol over which the data is to be transmitted.\n TCP: Transmission Control Protocol. It is connection-based transmission, which means that connection between the computers is established and maintained throughout the request. These layers are slower since it has a feedback mechanism. Via the feedback, it is ensured that the lost/corrupted data can be retransmitted. It is generally used for EMails, Loading Webpage, File Transfer. UDP: User Datagram Protocol. It is connectionless transmission, where there is a high chance of data being lost. It is up to the receiving computer to keep up with the data which is sent. In this case, data transportation is faster, but due to the lack of feedback mechanism, loss/corrupted data cannot be regained. It is generally used for Video Streaming, Calls.  The Transport layer divides the data into bite-sized pieces, where each piece contains a Source and Destination Port Number and Sequence Number.\n Port Number: Used to direct each segment to the correct Application Sequence Number: Used to reform the whole message in the correct order.  These bite-sized pieces are called Segments if using TCP and datagram if using UDP. They are then sent to the Network layer.\nThe Transport layer is also in charge of flow control. If the server sends data at a higher rate than our machine can handle, it communicates and asks to send data at a lower rate. If the server sends data at a lower rate, it communicates to send data faster. In TCP, if data is corrupted, it uses Automated Repeat Request to restore the data.\nüì¨ Network The Network layer is responsible for locating the destination of your request. The network layer takes the IP address (if you want to request information from a webpage) for the page and figures out the best route to take.\nLogical Addresses (here, IP Address) are used to provide order to networks, categorising them. Each segment is assigned a sender and receiver IP address, which is called a packet. These packets travel through the network.\nThe process of moving data packets from source to destination is called routing.\nüí≥ Data-Link Data packets are sent from the Network layer to the Data-Link layer. The Data-Link layer adds a MAC (Media Access Control) Address to each packet for sender and receiver to make a Frame. Inside every network-enabled computer is a NIC (Network Interface Card) that comes with a unique MAC.\nThe Data-Link layer serves another essential function. It checks if the received information is corrupted during transmission or not.\nüß∞ Physical The lowest layer of the OSI Model. The Physical layer receives data from the Data-Link layer as frames and converts them into binary format. Once it is converted into binary, it is then transmitted as electrical pulses.\nüì≤ Receiving When the second computer receives the message, it reverses the process. It starts at the physical layer and sends the data up to the application layer, stripping the added information (de-encapsulation) as it goes up.\n üìù References  TryHackMe Introductory Networking OSI Model Explained by TechTerms ","description":"How computers send data across networks (OSI model).","id":1,"section":"posts","tags":["network"],"title":"Networks","uri":"https://aurumnpegasus.github.io/website/posts/networks/"},{"content":"This blog contains explanation of the paper by Victor Allis called \u0026lsquo;A Knowledge-based Approach of Connect-Four\u0026rsquo;\nüìú Introduction Connect-Four is a game for two players. Both have 21 identical coins. In the standard form of the game, one set of coins is yellow, and the other is red. You play the game on a vertical, rectangular board consisting of 7 vertical columns of 6 rows each. Each time a player puts a coin down, it falls to the lowest unoccupied block in that column. Players make a move in turns.\nIf a player connects four coins either horizontally, vertically or diagonally, they win. Occupying each of the 7x6 blocks such that no other move is possible, and ensuring that there is no winning player, entails the draw condition.\nNow, some definitions to make referencing the board easier. The 7 columns are labelled \u0026lsquo;a\u0026rsquo; through \u0026lsquo;g\u0026rsquo;, while the rows are numbered 1 through 6. In this way, the lowest square in the middle column is called d1. For convenience\u0026rsquo;s sake, we are taking the first player as White (W) and second as Black (B) (similar to Chess).\nüõ£Ô∏è Approaching the Game Before you show off your excellent techniques, we need to first prove that the dumb approach does not work. It is easy to see that the number of possible positions is at most $3^{42} (\\geq 10^{20}).$ This upper bound is a very crude one and can be brought into better proportions. For this purpose, a program was written in the C programming language, which is mentioned later. For the standard, 7 x 6 board, the program saw an upper bound of $7.1* 10^{13}$.\nSo, too many possibilities, significantly less accuracy, brute force is not an efficient approach. A player cannot win just by instantiating each possible board and trying to follow it. You are a human after all, not a computer üòõ\n‚öÑ Some Possible Boards Let\u0026rsquo;s start small. Consider a board of n columns, but only 2 rows. My claim is that Black will never lose a game on this board. Even if n were to be practical infinity.\nThis is how B should play:\n Pair up all the n rows in groups of 2. If n is odd let the nth row be alone. If W plays in row 1, play in row 2 (pair). If W plays in row 2, play in row 1. If W plays in row N, play in row N.  This will always result in a draw, since only way W could win is if it were to get its coin in 4 consecutive rows side by side. This is prevented by B.\nAnother solved board is with 2n rows (even) and columns ‚â§ 6. This strategy could also be used for ensuring B always draws.\n If W plays in columns 1, 2, 5 or 6, B plays in the same column. If W plays for the first time in column 3 or 4, B plays in the other column. Otherwise, if W plays in column 3 or 4, and B can still play in it, B plays in the same column If W plays in column 3 or 4, and B can not play in it, B plays in the other column.  Since B never allows a vertical 4 for W, that is out of the question. For horizontal 4 at row 1, B ends up occupying at least 1 of the two bottom columns, hence denying that for W as well. For any other horizontal 4, it is only possible in odd rows for W. But in column 3 and 4, B ends up having at least 1 in either of the two in all odd rows. Diagonal is not possible at all since W will have all coins at odd rows in column 1, 2, 5 and 6.\n‚ò†Ô∏è Threats Useless Threats  The threats by W in row 3,4,5 are considered to be useless, due to the threat by B in row 2. Since W cannot move in column 2 and 6, it has to fill column 7. Even number of rows mean that W will still have the turn when column 7 is filled, meaning B will end up winning.\nWhether a threat is useless or useful is dependant on control of Zugzwang (explained later).\nOdd Even Threat A threat is only useful if a player is forced to play in a row just below that of the threat. Usually that happens when other columns are filled. In such cases, generally, W has only odd rows, and B has even rows.\nBlack has odd threats, and White has even. If they are in the same column, the lower threat will win (as seen above)\nGenerally speaking, W threat is stronger than that of B. Here is how everything rolls out:\n W has odd, B has even threat: W will win. W has even, B has even threat: B will win. W has even, B has odd threat: Draw. W has odd, B has odd threat: Draw.\nA simple example consisting of multiple threats is:   Here, B has odd threat at c3 and W has odd threat at f3. Going by the table, it should be a draw. Lets play it out. W has to give up its own threat to play the game, which would ideally result in a draw, since B will have to give up its threat in c. But what happens is that B gets to create a new threat at c2 due to coin at f5. This gives B consecutive threats, and thus it wins.\nThis tells us that though parity of threats tells us a good amount about the winner, we need to be careful about new threats.\n‚ùÇ Zugzwang This is a very basic but powerful concept in Connect 4. Zugzwang basically means to force a player to make a move they would rather not make. This is due to the simple rule that they have to make a move, and the constraints of the board.\nInitial Position W always moves first. Therefore B always is in a position to play follow up, hence to control the Zugzwang. Suppose B plays follow up from the beginning, you would end up with a board like this:\n Though this is an illegal position, it is interesting to note who won first. Since W controls whole first row, naturally W won the game first. This shows that follow up is not a good strategy at the start of the game for B.\nOther Positions The following board represents a position where W is in control of the Zugzwang:\n Here, W has an odd threat in column a. Knowing this, B won\u0026rsquo;t play there. Since on the rest of the board, odd number of squares are remaining, whoever plays first here, the opposite will have to play in column a. Since W is playing the first, it can control the zugzwang to force B to play at a2. The only option B has to go against the zugzwang and connect its 4 men, but still, it is W\u0026rsquo;s game to lose.\nIn this case, B has control of Zugzwang due to even threats\n B and W ideally do not want to be the first to play in b or f. Other than these 2, the total number of boxes remaining is even. This means whoever plays first here, will be the player *forced to play first in either column b or f. That means at the end, W will have to play in b1 or f1, thus losing. B is in complete control of Zugzwang here and can play follow up\n üìù References  Resources by Victor Allis Alpha Beta Pruning based heuristics Principles and Tehniques BY Stanford C4 Numbers by oeis org Math oriented resources behind Connect-4 ","description":"Exploring the paper by Victor Allis on how to view the game.","id":2,"section":"posts","tags":["paper","connect4"],"title":"Connect Four, Part-1","uri":"https://aurumnpegasus.github.io/website/posts/connect_four_1/"},{"content":"This blog contains explanation of the paper by Victor Allis called \u0026lsquo;A Knowledge-based Approach of Connect-Four\u0026rsquo;\nThis is a 2 part series exploring the paper, and I would suggest going through \u0026lsquo;first part\u0026rsquo; if you haven\u0026rsquo;t already.\nüïµÔ∏è‚Äç‚ôÇÔ∏è Strategies A formal definition is given of the nine rules which are used to refute potential threats of the opponent. These can be only applied by the player in control of the Zugzwang. These are always applied in the places opponent has to move.\nClaimeven This makes direct use of the fact that player in control of Zugzwang can get all even unclaimed positions, giving odd positions to the other.\n B is in control of Zugzwang here since W doesn\u0026rsquo;t have any threat. Here, if B were to use claimeven, he could end up getting a draw, since any threat of W will need to have a coin in even row, which will not be possible.\nBaseinverse This is based on the logic that a player cannot play two directly playable moves in one turn. Therefore once the opponent has made the move, controller of Zugzwang can still cover the other position.\n Here, if W cannot play in a1 and b1 at the same time. That means if W plays in a1, B plays in b1, and vice versa. Thus the threat is nullified.\nVerticle Similar to Baseinverse, this is based on the fact that a player cannot play two directly playable moves in a single column in one turn. Depending on the opponent, the player controlling the Zugzwang can either play second or first in the column to prevent a verticle 4.\nAftereven Aftereven uses a special side-effect of the usage of one or more Claimevens. If a group can be completed by the controller of zugzwang, then they can complete the whole board using claim even, and then complete that group:\n Here, B can use aftereven to complete the group at either b2 or f2. Here, then B can use claimeven to finally force W to play in either b1 or f1. This is called as aftereven, where you can form a group and win by using claimevens.\nLowinverse Lowinverse is based on the fact that two odd numbers when summed give an even number. Normally, controller of Zugzwang will play lowest even square of the column containing odd number of empty squares. But when we have two columns (doesn\u0026rsquo;t have to be consecutive) having odd number of empty squares, this will force the opponent to play first. In such a way controller of zugzwang gets to take the odd square above the opponent.\nHighinverse This is based on the same principle as that of lowinverse:\n In lowinverse, we would consider c2, c3, d2, d3 as important. Here we consider c4 and d4 as important too. Highinverse is nothing but a combination of lowinverse and claimeven. What this does is say W plays in c2, then using lowinverse B can get c3. Then B (controller of Zugzwang) convert d3 and d4 into a claimeven, to get d4. In such a way B ends up getting c3 and d4.\nBaseclaim This is a combination of Baseinverse and Claimeven:\n Here, W can possibly have 3 threats formed: b1-e1, c1-f1, b1-e4(diagonal). B needs to play in a way to counter this.\n W plays in b1, B plays in e1 and then uses Claimeven at c1-c2 to prevent b1-e4. W plays in c1, B plays in e1 and then uses Claimeven at b1-c2 to prevent b1-e4. W plays in e1, B plays in c1 and then uses Claimeven at b1-c2 to prevent b1-e4.  In such ways B can nullify all of W\u0026rsquo;s threats.\nBefore This is a combination of Claimeven and Vertical:\n Here b4-e1 is the Before group. Since b4 and e1 are still empty, this means it works for all groups needing both b5 and e2 (b5-e2). Here, before uses the squares b4-b5 and e1-e2. As soon as b4 is played, b5 is played, and same with e1-e2. This will ensure B completing b4-e1 or preventing W\u0026rsquo;s b5-e2. In both cases b5-e2 is a useless threat.\nIt basically means that if there is a before group, the opponent cannot claim all the unclaimed squares in the threat column.\nSpecial Before  We use d2-g2 as the before group. This can contain claim evens at f1-f2 and g1-g2 and vertical at e2-e3. We need to use baseinverse to solve a1-d1, which would give W a possibility of b1-e4. To combat this, we can use claimeven to get e4. This claimeven, however, is conflicting with vertical at e2-e3.\nThe only reason B needs to play e3 is to prevent d3-g3. So B can play d3 as well. If W were to play at d3 before, then B should immediately get e2 to continue with the Before play. Therefore to play a Special Before, we need a before group (d2-g2) with one of the empty squares as directly playable (e2). Furthermore, we need another playable square (d3).\nCombination  ‚ö´‚ö™ Black and White Black We have developed a set of rules which can be used to show that certain potential threats can be refuted. Since some of the rules depend on Zugzwang, it is important that the person who applies them is in control of the Zugzwang.\nB is in control of Zugzwang until W creates an odd threat. Till then if B just plays using the strategy. If W were to create a good threat (odd threat), B is no more in control of Zugzwang. Here we observe that no matter what B does from here on out, there generally will not be any set of rules which can refute that threat.\nFrom this we can conclude that we do not need to check who controls the Zugzwang for B before applying the rules. For if B is in control, we can apply the rules, if not, it doesn\u0026rsquo;t matter what B does.\nWhite W needs an odd threat to gain control of Zugzwang. Once it has that, he just needs to follow the strategic rules to fill up the rest of the board. If W has more than one odd threat, it can choose from which poison to kill B from.\nVictor A position in which W has to move, can be evaluated as B as controller of Zugzwang, and vice versa. For W as a controller of Zugzwang, evaluation must be done removing the odd column out of viable options. The evaluation begins with finding all possible instances of the 9 strategic rules.\nFor each position where any rule is applied, it is seen whether it can solve a problem or not. Each application of one of the rules which solve one or more problems is stored. These are called Solutions. This results in a list of solutions, where each solution is stored as a Struct. Struct consists of fields describing the rule, and the positions involved. Furthermore for each solution we have a list of groups solved by that solution.\nWe also create a map with problem as the key and list of pointer(s) to the solution as the values. After all this, we need to see which solutions can work together and which cannot. To work this out, solutions are seen as nodes of an undirected graph. If two solutions can\u0026rsquo;t be used simultaneously, they are connected. These connections are stored in an adjacency matrix. To fill it, it is important to know type of solutions and squares involved. Once it is filled, it is a normal square array.\nIf we see the problems as nodes, too, and we connect a solution and a problem if the solution solves the problem, and no problems are connected, we can solve it as a pure graph problem.\nGiven are two sets of nodes, S(olutions) and P(roblems). We try to find an allowable (in graph theory: independent) subset C(hosen) of S, with the property that P is contained in B(C) (the set of all neighbours of nodes in C)\nIt can be solved using a simple backtracking algorithm.:\ncpp  1 2 3 4 5 6 7 8 9 10 11 12 13  void FindChosenSet(P, S) { if (P == EmptySet) { Eureka(); // We have found a subset C  } else { MostDifficultNode = NodeWithLeastNumberOfNeighbours(P); for (auto neighbours: MostDifficultNode) { FindChosenSet( P - { MostDifficultNode }, S - AllNeighboursOf(ChosenNeighbour) ); } } }       'use strict'; var containerId = JSON.parse(\"\\\"8f18fe439141ec5d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  If a set of solutions is found for a given position, these solutions show the plan which has to be followed to play the game until the desired result (win for White, or at least a draw for Black) is reached.\nüß† Food for Thought Lets assume we have an oracle. This oracle cannot predict who will win, but for any given state of board, give the best possible outcome. Let us assume that we play such that for each state of board, we ask for help from the oracle. Therefore it is a \u0026lsquo;perfect\u0026rsquo; game. In such case, if W wins, does that mean W will always win if it were a perfect game?\nThe thing is, if for B we were to choose that draw is fine, it will not change any result. Since oracle predicts the best move, if the second scenario gives different result, that would mean Oracle could have chosen the best move, but did not. That is contradictory. That means that whoever will win with the help of the Oracle, is always at an advantage.\nAnother thought to explore is number of legal ways to arrange $N$ coins in board. For now, we take the board to be the standard $7 \\times 6$ board.\n üìù References  Resources by Victor Allis Alpha Beta Pruning based heuristics Principles and Tehniques BY Stanford C4 Numbers by oeis org Math oriented resources behind Connect-4 ","description":"Exploring the paper by Victor Allis describing strategies in the game.","id":3,"section":"posts","tags":["paper","connect4"],"title":"Connect Four, Part-2","uri":"https://aurumnpegasus.github.io/website/posts/connect_four_2/"},{"content":"This blog contains an explanation of the paper \u0026lsquo;The complexity of Scotland Yard\u0026rsquo; by Merlijn Sevenster.\nThis is part 1 of a two part blog. Part 1 explains the game, and lays out the foundations required for formalisation of the game. It also lists out the various assumptions we are going to consider in the game.\nThe blog was originally published on \u0026lsquo;GameLab\u0026rsquo; for our course project. The website also contains additional information about heuristics used in Scotland Yard, and similar analysis for other board games.\nüìñ Introduction Scotland yard is a popular board game, named after Scotland Yard, the headquarters of London\u0026rsquo;s Metropolitan Police Service. It is played by 2-6 players in which one of the players is the criminal (Mr. X) and the remaining are detectives. As is intuitive, the objective of the game for the detectives is to catch the criminal, while the objective of the criminal is to run away from its pursuers for 22 rounds. It is an asymmetric board game since the players do not have the same goal.\nüìú Rules Let\u0026rsquo;s take a look at the rules once, before we jump into analysing the game.\nMovement of players: Each detective and the criminal is assigned a pawn to mark their position on the board. There are a total of 199 positions on the Scotland Yard board. Each position can represent 1-3 stations, a taxi, a bus, and an underground route, which is marked by a number and the colour of the station it represents.\nEvery station on the map can be reached with the taxi (yellow). However, the distance that you can travel is short: You can only move (along the yellow line) to the next station.\nThe bus (turquoise) only drives from stations with a turquoise semi-circle; a bus will take you a little further than the taxi (along the bus line).\nThe underground (red) travels along the red line and covers the furthest distances the quickest. However, there are only a few underground stations (stations with a red inner rectangle) on the map.\nAll playing pieces can only be moved to unoccupied stations. If there are no unoccupied stations for Mister X to travel to, he has lost the game. Mister X also loses if one of the detectives moves to the station where Mister X is located.\nScotland Yard Map   Tickets Each detective receives ticket cards that allow him to across the board. At the start of the game, each detective gets 4 underground tickets, 8 bus tickets, and 11 taxi tickets, and each detective receives 5 black tickets and 2 double move tickets.\nIn each round, after a detective has used up a ticket to travel to another position, they cannot use them again, however, this ticket is now available for Mr. X\u0026rsquo;s use. If a detective no longer has any tickets or can\u0026rsquo;t move from his current station with the tickets he has left, they have to sit out.\nA black ticket allows Mr.X to hide the route he used and also travel by ferry (a route only he is allowed), and a double move ticket allows him to make two moves to two different stations in one round.\nInitial Starting Position To determine each player‚Äôs starting position, a set of start cards marked D and X are shuffled separately and each detective selects from the D cards and places their playing piece on the respective position. Mr. X picks an X card but doesn‚Äôt reveal his position to the detectives or place his playing piece on the board.\nGameplay In total, 22 rounds are played. In each round, Mr. X first makes their move, concealing his new position from the remaining players, and writes down the station he moved to on a paper, hiding the station with the ticket they used. (The detectives can see which mode of transport Mr.X has used.)\nWhen a detective makes a move, the used-up ticket is placed in the general draw pile where Mr. X gets his tickets (so Mr. X basically has an unlimited number of tickets).\nMoving Mr. X Each turn Mr. X conceals his move. However, there are special moves (3rd, 8th,13th, 18th, and 24th moves) where Mr. X must surface. He has to reveal his current position before moving to a new station, which gives detectives the chance to co-ordinate and corner the criminal!\nMoving the Detectives The detectives use their tickets to move around the board. If they run out of tickets or don\u0026rsquo;t have the required ticket to move out of a station, they must sit out of the game. Detectives can\u0026rsquo;t trade tickets among themselves and all their remaining tickets have to be visible to Mr. X, so he can see the remaining means of transportation they have left.\nWinning the Game Mr. X wins if -\n He is able to move around the board for 22 rounds without being caught.  The detectives win if -\n They corner Mr. X (he has no stations to go to where a detective is not present) They move to a station where Mr. X is currently  Now that we understand how to play, let\u0026rsquo;s dive into different aspects of the game!\nüéØ Objective The goal of this page is to analyze the game Scotland Yard.\nWe start off by venturing into proofs for Scotland Yard being a PSPACE problem and the similarities between Scotland Yard and a game of perfect information. It is easy to feel daunted by these claims, trust me I felt it too. To make it easier, we remove all the layers of abstraction from the game first. We convert the game into a problem of Groups, Graphs, and Sets.\nIt is understandable if you think it still is going to be tough. We ensure that you will understand what these jargons are and how they interact with the game itself. We firstly introduce Games with the viewpoint of perfect and imperfect information. Then we connect Scotland Yard to that idea and remove all the layers of abstraction. Once that is done, we proceed with proofs.\nüèóÔ∏è Laying the Foundation To properly explain some concepts, we need to define some terms:\nExtensive Games: Games that allow the representation of various key aspects. These aspects include a set of players, each player\u0026rsquo;s moves, their decisions, the information (possibly imperfect) about a player, and their payoffs for all possible outcomes. Essentially, they are games that can be represented with a game (decision) tree.\nPerfect Information Game: In a perfect information game, a player has complete information about all events which have previously occurred in the game.\nImperfect Information Game: Games which have some aspects of the game hidden are called imperfect information game.\nIt is easily understandable why Scotland Yard comes under the bracket of the extensive game with imperfect information. For it to be an extensive game, it should formally represent each and every aspect of the game, which is the moves and mode of commutation each player uses. Even if the moves are hidden, they are definite and are represented. Since the moves are hidden, it is impossible for the detectives to know which route the criminal has taken, which makes it an imperfect information game.\nNow, let\u0026rsquo;s look into some abstraction or representations.\nAny win-loss game $G$ with perfect information can be represented as a 4-tuple\n$$G = \u0026lt; N, H, P, U\u0026gt;$$\n $N$: Represents the number of total players. $H$: Is a set of histories. A history ($h$) represents a given state of the board at some point in time. Every $h = \u0026lt;a_1, a_2, . . a_p \u0026gt; $, where $a_i$ is an action. Each history is an ordered list of actions. $h'$ = $\u0026lt;h, a'\u0026gt;$ represents the immediate successor of $h$, where $h'$ = $\u0026lt; a_1, a_2 . . . a_p, a'\u0026gt;$. There are two types of history, terminal ($Z$) and non-terminal ($H-Z$). Terminal represents an end condition, after which no other action can be taken. A history becomes terminal when a player wins. $P$: Is the player function. It assigns to each non-terminal history a particular player. Formally, we define it as $P:$ { $H - Z$ } $\\rightarrow N$. We say that a history $h$ belongs to $P(h)$, essentially when the last action in the set of actions that is $h$ is made by the player. $U$: Is the utility function, assigning each terminal history to a player. (the player has won the game). The formal definition would be $U: Z \\rightarrow N$  Given $G$ defined as above, a function $S$ is called a strategy for a player $\\space i \\in N i‚ààN$ if it maps for every history $h$ belonging to $i$ to an action $A(h)$.\nAn extensive game with imperfect information extends a game with perfect information. To represent the former, all you need is to add is an Information function in the original tuple.\n$$G = \u0026lt; N, H, P, \\langle \\mathcal{I}_i \\rangle _{i \\in N}, U \u0026gt;$$\nThe only difference in this is that $\\mathcal{I}_i$ carries information sets for each $i \\in N$. $\\mathcal{I}_i =$ {$I_1, I_2, . . . I_q$}. where each $I$ represents a set of histories, there having been $q$ rounds of the game played so far. Each $I$ basically is a set of histories (or state changes of the board) of that round (till $i$ makes an action again). Intuitively, an extensive game with imperfect information models the situation in which player $i$ knows that some history $h \\in I \\in \\mathcal{I}_i$ has happened, but there are unable to tell hh apart from the other histories in $I$.\nIn simple terms, they know other players have made a move based on the last action they took, but are not completely sure of the previous actions the player took.\nA function $S$ is called a strategy for a player $i$ in $G$ if it maps every information partition $I \\in \\mathcal{I}_i$ belonging to $i$ onto action in $A(I)$\nAssumptions for Mathematical Modelling For convenience, there are some assumptions which have been taken.\n There is only 1 mode of transport, that is Taxi. The same method described as follows can be easily translated with more modes of transport. A player will have $k$ amount of tickets of Taxi, where $k$ = number of rounds. There are only two players, Detective and Mr X. Only 1 player will be controlling all detectives. Value of $k$ will be always $\\leq |V|$, where $V$ is the number of nodes in the graph. We have used digraph to represent the game board. Mr. X will always play the first move in each round. Mr. X will be considered to be caught IF AND IF ONLY it is on a node occupied by a detective at the END of the round (after detectives have moved). Mr X will win if and if only the game goes on for $\u0026gt;k$ rounds, otherwise Detectives have won.  üìù References   P. Nijssen and M. H. M. Winands, \u0026ldquo;Monte Carlo Tree Search for the Hide-and-Seek Game Scotland Yard,\u0026rdquo; in IEEE Transactions on Computational Intelligence and AI in Games, vol. 4, no. 4, pp. 282-294, Dec. 2012, doi: 10.1109/TCIAIG.2012.2210424.\n  Sevenster, Merlijn. (2006). The complexity of Scotland Yard. Journal of Pharmacology and Experimental Therapeutics - J PHARMACOL EXP THER.\n ","description":"Proving that Scotland Yard is of P-Space complexity.","id":4,"section":"posts","tags":["paper","scotland yard"],"title":"Scotland Yard: Part 1","uri":"https://aurumnpegasus.github.io/website/posts/scotland_yard_1/"},{"content":"This blog contains an explanation of the paper \u0026lsquo;The complexity of Scotland Yard\u0026rsquo; by Merlijn Sevenster.\nThis is part 2 of a two part blog. Part 1 explains the game, and lays out the foundations required for formalisation of the game. It also lists out the various assumptions we are going to consider in the game. Part 2 formalises the game and proves that it is of PSPACE complexity.\nThe blog was originally published on \u0026lsquo;GameLab\u0026rsquo; for our course project. The website also contains additional information about heuristics used in Scotland Yard, and similar analysis for other board games.\nü§µ Formalisation We now know how to formalise any given perfect or imperfect information game. Now let\u0026rsquo;s connect it to the game Scotland Yard.\nLet $SY$ = $\\langle G, \\langle u_* \\overrightarrow{v_*} \\rangle, f \\rangle $ be a Scotland Yard instance. Then, let the extensive Scotland Yard game constitute by $\\mathcal{SY}$ be defined as the tuple\n$$ \\mathcal{SY}(SY) = \\langle N, H, P, \\bullet, U \\rangle $$\nHere,\n  $G$ represents a digraph\n  $u_*$ represents the position of Mr X.\n  $\\overrightarrow{v_*}$ is $n$ dimensional vector, where $n$ is the number of detectives. Each element in the vector represents the initial node of the detective.\n  $f$ is a function which when fed a number (no. of rounds) chooses one of the two elements from the set { $show, hide$ }. This denotes whether Mr X needs to show their position or not.\n  $N$ represents total number of players. For convenience, $N =${$\\forall, \\exists$} where $\\forall$ represents Mr X and $\\exists_1, \\exists_2 . . \\exists_{N-1}$ represent the detectives.\n  $H$ represents a set of histories. Let $\\prec$ be the immediate successor relation on $H$ . So you can say that $\\langle h \\rangle \\prec \\langle h, u \\rangle$ where $\\langle h \\rangle, \\langle h, u\\rangle \\in H$\n  $P$ represents the player function. Due to notational convenience, it is easy to assign the value of the player function. $P(\\langle h, u \\rangle) = \\forall P$ and $P(\\langle h, u , \\overrightarrow{v} \\rangle ) = \\exists$ no matter $u$ or $\\overrightarrow{v}$\n  $\\bullet$ is the indistinguishability relation. It is defined on the group $H$. For any two histories $h, h' \\in H$ where the length of both histories is equal, $h \\bullet h'$ when:\nIf $h = \\langle u_* , \\overrightarrow{v_*}, u_1, \\overrightarrow{v_1}, . . . u_i, \\overrightarrow{v_i} \\rangle$ and $h' = \\langle u_* , \\overrightarrow{v_*}, u'_1, \\overrightarrow{v'_1}, . . . u'_i, \\overrightarrow{v'_i} \\rangle$ then\n $\\overrightarrow{v_j} = \\overrightarrow{v'_j} \\space \\forall \\space 1 \\leq j \\leq i$ and $u_j = u'_j \\space \\forall \\space 1 \\leq j \\leq 1$ such that $f(j) = show$    $U : Z \\rightarrow $ {$win,lose$} is the utility function which determines whether $\\exists$ won or not.\n  $$ U(\\langle h, u, \\overrightarrow{v} \\rangle) = \\begin{cases} win, \\space \\space u\\in \\overrightarrow{v} \\\\\\ lose, \\space \\space u \\notin \\overrightarrow{v} \\end{cases} $$\nIt is easy to see that the operation $\\bullet$ is Equivalent to the group $H$. We write $\\mathcal{H} \\subseteq \\wp(H)$ for the set of equivalent classes, or information cells, in which $H$ is partitioned by $\\bullet$.\n$\\mathcal{H} = \\{ C_1, C_2 . . . C_n\\}$ where $H = C_1 \\cup C_2 . . \\cup C_m$ for every $1 \\leq i \\leq m$, if $h \\bullet h'$ where $h, h' \\in C_i$.\nWe lift the relation $\\prec$ to $H$, using the same symbol: For any pair $C, C' \\in H$ we write $C \\prec C'$ if there exists histories $h \\in C$ and $h' \\in C'$ such that $h \\prec h'$\nWe can also extend this as if $h, h' \\in C$ and $C \\in H$, then $P(h) = P(h')$. Thus the player function is meaningfully lifted as follows: if $C \\in H$ and $h \\in C$, then $P(C) = P(h)$.\n Consider an example game $G^x$. Let $f^x$ be the information function where $f^x(1) = hide$ and f^x(2) = show. Let $u_*$ and $v_*$ as the initial position of $\\forall$ and $\\exists$. Consider that number of detectives to be 1. Let\u0026rsquo;s play this game.\nThe set of histories we can get from this game are:\n where ! marks terminal histories. To reflect that this is a game of imperfect information, we can write $\\mathcal{H}$ as\n A graphical representation of this would be:\n Perfect Information Scotland Yard So, Perfect Information means that each and every aspect of the game is explicitly expressible. The only difference we need to model here is $\\forall$\u0026rsquo;s whereabouts. Since describing each position will convert Scotland Yard into a simple game of Cops and Thieves, we don\u0026rsquo;t do that. Instead, to preserve the game, we describe the position of $\\forall$ as a set of possible nodes.\nMore abstractly, $\\forall$‚Äôs powers are lifted from the level of picking up vertices to the level of picking up sets of vertices. $\\exists$‚Äôs powers remain unaltered, as compared to the game with imperfect information that was explicated above. It is defined as:\n$$ \\mathcal{SY-PI}(SY) : \\langle N_{PI}, H_{PI}, P_{PI}, U_{PI} \\rangle $$\nThe above mentioned example will be converted to\n Effective Equivalence In this section, we establish that $\\exists$ has a winning strategy in $\\mathcal{SY}(SY)$ iff it has a winning strategy in $\\mathcal{SY-PI}(SY)$. In order to prove this, it will be shown that $\\langle H, \\prec \\rangle$ is isomorphic to $\\langle H_{PI}, \\prec_{PI} \\rangle$ in virtue of the bijection $\\beta$\nThe function $\\beta$ is a map from histories in the perfect information game $\\mathcal{SY-PI}(SY)$ to information cells in the game $\\mathcal{SY}$. To formally define it, $\\beta: H_{PI} \\rightarrow \\wp(H)$.\nFor example, in the above mention $G^X$ we will map $\\beta(\\langle u_*, v_*, u_1 \\rangle)$ where $u_1 = \\{a, b\\}$ to $C_1$ where $C_1 = \\{\\langle u_*, v_* , a\\rangle , \\langle u_*, v_*, b \\rangle \\}$\nJust as a reminder, $C_i$ represents an indistinguishable state for $\\exists$ in $\\mathcal{SY}(SY)$.\nThe perfect information Scotland Yard game was defined in such a way that $\\exists$\u0026rsquo;s imperfect information in $\\mathcal{SY}(SY)$ is propagated to perfect information about sets in $\\mathcal{SY-PI}(SY)$.\nExample of $\\beta$ in lieu of above mentioned example would be:\n It is important to note that though here $\\beta$ is defined to have a codomain $\\wp(H)$, it ends up having a range of $\\mathcal{H}$. This is due to the output always being $C_i$ and $\\mathcal{H} = \\{C_1, C_2 . . C_m \\}$\nTo better define $\\beta$ and actually make it bijective, we redefine it as\n$\\beta: H_{PI} \\rightarrow \\mathcal{H}$\nNow, let\u0026rsquo;s prove that the groups $\\langle H, \\prec \\rangle$ and $\\langle H_{PI}, \\prec_{PI} \\rangle$ are isomorphic.\nIt is proved that $\\beta$ is a bijection between $H_{PI}$ and $\\mathcal{H}$. It remains to be shown that $\\beta$ preserves structure.\nRecall that for $C' \\in \\mathcal{H}$ to be an immediate successor of $C \\in \\mathcal{H}$, there must exist two histories $g, g'$ in $C, C'$ respectively such that $g \\prec g'$ (Proved earlier).\nWhat this proves is that for any histories $h, h' \\in H_{PI}$ it is the case that $h \\prec_{PI} h'$ iff $\\beta(h) \\prec \\beta(h')$\nThe claim is proved by a straightforward inductive argument on the length of the histories in $H_{PI}$\nMaking use of the fact that $\\langle H_{PI}, \\prec_{PI} \\rangle$ and $\\langle H, \\prec \\rangle$ are isomorphic groups, an inductive argument proves that $S$ is a winning strategy for $\\exists$ in $\\mathcal{SY-PI}$ iff $S(\\beta)$ is a winning strategy for $\\exists$ in $\\mathcal{SY}(SY)$.\nüåå PSPACE Let $\\text{SCOTLAND YARD}$ be the set of all Scotland Yard instances such that $\\exists$ has a winning strategy in $\\mathcal{SY}(SY)$.\nIf we are able to prove that there is a winning strategy in PSPACE for $\\mathcal{SY}(SY)$, then it will stand true for $\\mathcal{SY-PI}(SY)$ as well.\nPapadimitriou, namely, observed that deciding the value of a game with perfect information can be done in PSPACE if the following requirements are met:\n The length of any legal sequence of moves is bounded by a polynomial in the size of the input Given a ‚Äúboard position‚Äù of the game there is a polynomial-space algorithm which constructs all possible subsequent actions and board positions; or, if there aren‚Äôt any, decides whether the board position is a win for either player.  $SY‚àíPI(SY)$ meets those condition.\nFor the first point, the length of the description of any history is bounded by the number of rounds $k$, of the game. By assumption, $k \\leq |V|$, thus it is polynomially bounded.\nFor the second point, as we have seen till now, each board game can be represented in form of a decision tree. More formally, if $\\langle h, U, \\overrightarrow{v} \\rangle$ is a non terminal history, then its successors are either (depending on $f$) only $\\langle h, U, \\overrightarrow{v}, \\{w_1 ,. . ., w_m \\} \\rangle$ or all of $\\langle h, U, \\overrightarrow{v}, \\{ w_1 \\} \\rangle$, . . . , $\\langle h, U, \\overrightarrow{v}, \\{ w_m \\} \\rangle$\nWhere $E(U-\\{\\overrightarrow{v}\\}) = \\{ w_1, w_2 , . . , w_m\\}$. These can easily be constructed in PSPACE.\nHENCE PROVED $\\mathcal{SY-PI}(SY)$, AND CONSEQUENTLY, $\\mathcal{SY}(SY)$ ARE PSPACE IN COMPLEXITY.\nNOTE\nIt is later shown that if there were a Scotland yard instance such that each $f = show$, then it would be PSPACE HARD in complexity. Also if each $f = hide$, then it would be NP HARD in complexity. These proofs are omitted due to the complexity of the math involved.\nüìù References   P. Nijssen and M. H. M. Winands, \u0026ldquo;Monte Carlo Tree Search for the Hide-and-Seek Game Scotland Yard,\u0026rdquo; in IEEE Transactions on Computational Intelligence and AI in Games, vol. 4, no. 4, pp. 282-294, Dec. 2012, doi: 10.1109/TCIAIG.2012.2210424.\n  Sevenster, Merlijn. (2006). The complexity of Scotland Yard. Journal of Pharmacology and Experimental Therapeutics - J PHARMACOL EXP THER.\n ","description":"Proving that Scotland Yard is of P-Space complexity.","id":5,"section":"posts","tags":["paper","scotland yard"],"title":"Scotland Yard: Part 2","uri":"https://aurumnpegasus.github.io/website/posts/scotland_yard_2/"},{"content":"Hey, I am Shivansh. I like learning stuff, and I like teaching as well. So, I decided to make this blog, where I will write tutorials about stuff I learn and do. Hopefully, it might end up helping someone one day. The blogs up here will not be restricted to what I study (which varies a lot). It will have posts about literally anything I feel like writing, though I will try to write them professionally.\nFeel free to connect with me on any of the socials provided (ideally via mail üòõ) for feedback or discussion about any topic.\n","description":"Hey, Welcome to my blog","id":7,"section":"","tags":null,"title":"About","uri":"https://aurumnpegasus.github.io/website/about/"}]