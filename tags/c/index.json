[{"content":"The blog explains how to find reduced row-echelon form of a matrix in python\nüìñ Introduction A matrix being in a row-echelon form means that Gaussian elimination has operated on the rows. A matrix is said to be in column-echelon form if its transpose is in row-echelon form. The specific conditions of RE are:\n All rows consisting of only zeros are at the bottom The leading coefficient (pivot) of a non zero row is always to the right of the leading coefficient of the row above it  RREF (Reduced Row-Echelon Form) has 2 more conditions:\n Matrix must be in RE form All pivots must be 1 Each column containing a leading 1 has zeros everywhere else.  One might achieve the RREF via elementary row operations, and here is a code for that!\nüë®‚Äçüè´ Code Essentially, we want to do this:\nPython  1 2 3 4 5 6 7 8 9 10 11  def rref(matrix): dimension = matrix.shape numrows = dimension[0] numcols = dimension[1] lead = 0 # or pivot for r in range(numrows): # \u0026lt;END: if you reach last column\u0026gt; # \u0026lt;LOOP: to find next pivot\u0026gt; # \u0026lt;CONVERT: convert all other rows based on pivot\u0026gt;       'use strict'; var containerId = JSON.parse(\"\\\"e9932f6b2653e763\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nNow, lets write code for each one by one. The first part is END, which is essentially that if you dont have any more columns, it means that the matrix is already in a RREF state, hence return.\nPython  1 2 3 4  # END: if lead \u0026gt;= numcols: print(self.matrix) return       'use strict'; var containerId = JSON.parse(\"\\\"b69e38067458b5bd\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  The loop parts requires you to go through each column in the row to determine if the number is suitable to be a pivot. If you find none, then go to the next column! (this means current column was all zeros and must be put at last). If there are no pivots at all to be found, that means you have already reached RREF\nPython  1 2 3 4 5 6 7 8 9 10 11 12 13 14  # LOOP: index = r while matrix[index][lead] = 0: index += 1 if numrows == index: # No pivots in my row, all zeros lead += 1 if lead == numcols: # No pivots at all print(matrix) return # Swap if I had to go to the next column matrix[[index, r], :] = matrix[[r, index], :]       'use strict'; var containerId = JSON.parse(\"\\\"e0b6f67b362062ca\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  I have my pivot now matrix[r][lead], which I need to convert to 1 via elementary row operations. Once that is done, everything else in the column needs to be converted to 0s as well\nPython  1 2 3 4 5 6 7 8 9  # CONVERT: # R = R/k matrix[r] = matrix[r] / matrix[r][lead] for i in range(numrows): if i != r: # I = I - cR matrix[i] = matrix[i] - matrix[i][lead]*matrix[r]       'use strict'; var containerId = JSON.parse(\"\\\"8cac965be3aed02e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  üö∂‚Äç‚ôÇÔ∏è Walkthrough: Text  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  matrix: array([[ -12, 12, 2], [ 12, -12, -2], [ 2, -2, -17]]) _______________________________________________________________________ Iteration 1: lead = 0, i = 0, r = 0 After Swapping: matrix: array([[ -12, 12, 2], [ 12, -12, -2], [ 2, -2, -17]]) Dividing by -12: matrix: array([[ 1, -1, 0], [ 12, -12, -2], [ 2, -2, -17]]) matrix[i] = [ 12 -12 -2] - 12*[ 1 -1 0] matrix[i] = [ 12 -12 -2] - 12*[ 1 -1 0] After Iteration 1: matrix: array([[ 1, -1, 0], [ 0, 0, -2], [ 0, 0, -17]]) _______________________________________________________________________ Iteration 2: lead = 1, i = 1, r = 1 After Swapping: array([[ 1, -1, 0], [ 0, 0, -2], [ 0, 0, -17]]) Dividing by -2: matrix: array([[ 1, -1, 0], [ 0, 0, 1], [ 0, 0, -17]]) matrix[i] = [ 1 -1 0] - 0*[0 0 1] matrix[i] = [ 0 0 -17] - -17*[0 0 1] After Second Iteration: matrix: array([[ 1, -1, 0], [ 0, 0, 1], [ 0, 0, 0]]) _______________________________________________________________________ Third Iteration: since lead \u0026gt;= numcols, exit       'use strict'; var containerId = JSON.parse(\"\\\"68bd386936d3ca3c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  üñ•Ô∏è Final Code: Python  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  import numpy as np class RREF: def __init__(self, matrix): self.matrix = matrix def rref(self): dimension = self.matrix.shape numrows = dimension[0] numcols = dimension[1] lead = 0 for r in range(0, numrows): if numcols \u0026lt;= lead: print(self.matrix) return index = r while self.matrix[index][lead] == 0: index += 1 if numrows == index: index = r lead += 1 if lead == numcols: print(self.matrix) return # swap if my row is all 0s self.matrix[[index, r], :] = self.matrix[[r, index], :] # make my first number = 1 self.matrix[r] = self.matrix[r] / self.matrix[r][lead] for i in range(numrows): if i != r: print(f\u0026#34;Matrix: self.matrix[i] = {self.matrix[i]}- {self.matrix[i][lead]}*{self.matrix[r]}\u0026#34;) self.matrix[i] = self.matrix[i] - self.matrix[i][lead]*self.matrix[r] lead += 1 ic(self.matrix) m = np.array([ [-12, 12, 2], [12, -12, -2], [2, -2, -17] ]) r = RREF(m) r.rref()       'use strict'; var containerId = JSON.parse(\"\\\"e2585b190bf98462\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  üîñ References:  Understanding RREF from wikipedia Psuedocode from Rosetta Code, containing implementation in lots of different languages! ","description":"Writing code to find RREF of a matrix from scratch","id":0,"section":"posts","tags":["matrix"],"title":"Reduced Row Echelon Form","uri":"https://aurumnpegasus.github.io/website/posts/rref/"},{"content":"The blog explains how to create a linear classifier from scratch using MSE loss and Sigmoid Function.\nüìñ Introduction A classifier is a machine that can differentiate between objects of two or more different classes. We define a Loss Function J as the Mean Squared Error of the actual value vs the predicted value. The machine learns to differentiate between classes by minimising the function J (via gradient descent). For simplicity and explainibility, we have considered two categories and are trying to find a line that divides these two classes.\nThe explanation below assumes that the reader has a decent understanding of calculus and gradient descent algorithms.\nüíΩ Dataset We artificially generate a dataset using NumPy. Two classes are shown in a two-dimensional plot in red and blue, with class 1 centred around (-5, 3) and class 2 centred around (3, -5). We use the same covariance matrix for both classes.\n \nOur training dataset consists of 1000 samples, with 500 belonging to class 1 and 500 belonging to class 2. The test dataset consists of 200 samples, with 100 belonging to each class.\nFirst, we get multiple samples from a multivariate normal distribution using NumPy.\nPython  1 2 3 4 5 6 7 8 9 10 11 12 13  def getClasses(self): # Assumed equal amount of samples in each class, you can take anything # covariance matrix = [[12, 0], [0, 12]] # mean_a = [-5, 3] train_a = np.random.multivariate_normal(self.mean_a, self.covariance, self.train_len//2) test_a = np.random.multivariate_normal(self.mean_a, self.covariance, self.test_len//2) # mean_b = [3, -5] train_b = np.random.multivariate_normal(self.mean_b, self.covariance, self.train_len//2) test_b = np.random.multivariate_normal(self.mean_b, self.covariance, self.test_len//2) return train_a, test_a, train_b, test_b       'use strict'; var containerId = JSON.parse(\"\\\"e5073a0fb336ed46\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Once we have samples from the two classes, we append them together (and add 1 for bias) to get train and test dataset.\nPython  1 2 3 4 5 6 7 8 9  def handle(self): train_a, test_a, train_b, test_b = self.getClasses() # Assigning 1 label to class A and -1 to class B self.train_x = np.concatenate((np.concatenate((train_a, train_b), axis=0), np.asmatrix(np.ones(self.train_len)).T), axis=1).T self.train_y = np.asmatrix(np.concatenate( (np.ones(self.train_len//2), -1*np.ones(self.train_len//2)), axis=0)) self.test_x = np.concatenate((np.concatenate((test_a, test_b), axis=0), np.asmatrix(np.ones(self.test_len)).T), axis=1).T self.test_y = np.asmatrix(np.concatenate( (np.ones(self.test_len//2), -1*np.ones(self.test_len//2)), axis=0))       'use strict'; var containerId = JSON.parse(\"\\\"b42edeb0c0a96421\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  üìâ Gradiant In two dimensions, a linear classifier is just a line. Let us denote it by $f$ . We define our dataset as $x = [x_0, x_1, 1]$ and weight $w = [w_0, w_1, w_2]$, where $w$ is the term we want to learn. Though our samples are in two-dimensions, we have $x$ as three-dimensional vector so as to account for bias.\nSince we are using MSE loss, we get:\n$$ J = \\frac{1}{N} \\mid \\mid y - \\sigma(w.x^T) \\mid \\mid^2 $$\nWhere:\n$J$ is the loss function\n$N$ is the number of samples\n$y$ is the correct output\n$\\sigma(w.x^t)$ is the predicted output\nNow, we can differentiate it as:\n$$ \\nabla J = \\frac{\\text{d} J}{\\text{d} w} = \\frac{1}{N} \\times 2 \\times (y - \\sigma(w.x^T)) \\odot \\frac{\\text{d} (y - \\sigma(w.x^T))}{\\text{d}w}$$\nThe symbol $\\odot$ symbolises Hadamard Product.\nAccording to in-depth proof, we get:\n$$ \\frac{\\text{d} \\sigma(x)}{\\text{d} x} = \\sigma(x) ( 1- \\sigma(x) ) $$\nSubstituting this formula\n$$ \\nabla J = \\frac{2}{N} \\times (y - \\sigma(w.x^T)) \\times \\sigma(w.x^T) (1 - \\sigma(w.x^T) \\times x^T$$\nüö´ Classification We have the gradiant, now using the gradiant descent formula we get\n$$ w = w - \\eta\\times \\nabla J $$\nContinue doing this till the difference in improvement is less than 0.0001 (arbitrary number)\nPython  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  def training(self): x, y = self.g.getTrain() # Pre-defining weights as 1 w_prev = np.asmatrix(np.zeros(3)) w = np.asmatrix(np.ones(3)) train_errors = [] iteration = 0 while np.linalg.norm(w - w_prev) \u0026gt; 1e-4: # Computing the loss via MSE loss = 1/ self.train_len * np.linalg.norm(y - self.sigmoid(np.matmul(w, x)))**2 train_errors.append(loss) w_prev = w # w = w - Œ∑‚àáJ # @: hadamard product, matmul: dot product w = w - self.eta*2 / self.train_len * ( np.mat(np.array(-y)*(np.array(self.sigmoid(w@x))*np.array((1-self.sigmoid(w@x)))))@x.T + np.mat(np.array(self.sigmoid(w@x))*np.array(self.sigmoid(w@x))*np.array(1 - np.array(self.sigmoid(w@x))))@x.T ) iteration += 1 return w       'use strict'; var containerId = JSON.parse(\"\\\"de2ddb6c3ce13af0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ü§∑ Results We use the learned $w$ to create the classification line (this is only possible since we have a 2-dimensional space, for higher dimensions it is impossible to visualise such equations).\nPython  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  weights = t.training() m = -weights[0, 0] / weights[0, 1] c = -weights[0, 2] / weights[0, 1] x = np.linspace(-15, 15, 300) y = m*x + c # Plotting the line on train dataset (can do the same for test dataset as well) plt.figure(figsize=(8, 8)) plt.scatter([point[0] for point in train_a], [point[1] for point in train_a], color = \u0026#39;green\u0026#39;, label = \u0026#39;Class 1\u0026#39;) plt.scatter([point[0] for point in train_b], [point[1] for point in train_b], color = \u0026#39;blue\u0026#39;, label = \u0026#39;Class 2\u0026#39;) plt.plot(x, y, \u0026#39;-r\u0026#39;) plt.legend() plt.show()       'use strict'; var containerId = JSON.parse(\"\\\"b241efea1435348b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  We see the learned classifier performing well on the training set:\n\nTesting the same on test dataset we find:\n üìù References: Introduction to DL: https://github.com/sayarghoshroy/Intro_to_DL_tutorial\n","description":"Creating a Linear Classifier using Sigmoid Function from scratch.","id":1,"section":"posts","tags":["sigmoid","hadamard"],"title":"Linear Classifier","uri":"https://aurumnpegasus.github.io/website/posts/sigmoid/"},{"content":"This blog contains an explanation and tutorial to create word embeddings via co-occurance matrix and svd\nüìú Introduction A computer cannot understand the language of humans. It can do a lot by understanding where and how words occur in a sentence, but it still cannot understand the semantics of a word. To map the human semantic space into something which a computer can understand, compute and work with, Word-Embedding Space is created. This is an n-dimensional vector space where each vector within it represents a word. Words similar in meaning are close together, and words that are opposites are farther apart.\n‚ùì Problem The problem here is that we are given a huge .json file which contains bunch of reviews. Our goal is to create a word embedding space by it so that we can represent all the words and their meaning via n-dimensional vectors\nüíΩ Preparing Data Data preparation for the task is quite simple, we will extract the reviews and tokenize them. We will not be removing stop words or lemmatizing since all high frequency words are important.\nFirst, we read the reviews from given json file. I have used ijson, which is a library which helps in iteratively parse huge json files (instead of loading the whole file to the RAM). I have also used spacy for tokenizing since its one of the best at it.\nThe below code is simple to understand, I have created a class which creates our vocabulary, and tokenizes the sentences. There are various methods to do this but I felt this was a really cool and modular way to achieve this!\nPython  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  import ijson import spacy class Data: def __init__(self): # All the variables in uppercase are globally defined constants self.path = PATH self.limit = LIMIT self.window = WINDOW self.nlp = spacy.load(DATASET) self.word2index = {} self.index2word = {} self.vocab = [] self.index = 0 def getSentences(self): return self.sentences def getVocab(self): return self.word2index, self.index2word, self.index, self.vocab def readJSON(self, limit, path): # Reading sentences line by line sentences = [] f = open(path) for item in ijson.items(f, \u0026#39;reviewText\u0026#39;, multiple_reviews=True): sentences.append(item) if len(sentences) == limit: break return sentences def addWords(self, word): # Adding words to vocabulary (if they don\u0026#39;t exist in it previously) if word not in self.word2index: self.word2index[word] = self.index self.index2word[self.index] = word self.vocab.append(word) self.index += 1 def createVocab(self, sentences): # Going line by line and token by token for sent in sentences: words = self.nlp(sent) for word in words: self.addWords(word.text) def handle(self): self.sentences = self.readJSON(self.limit, self.path) self.createVocab(self.sentences)       'use strict'; var containerId = JSON.parse(\"\\\"767a35ef64022505\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  üî¢ Creating Co-Occurance Matrix Usually, the limit of numpy matrices are around the region of 1e5*1e5. In some cases, the data might exceed this limit, hence I have used sparse matrices (so that all the cases are covered). Sparse matrices are able to hold larger matrices given that they are sparse in nature (mostly 0s).\nI have used lil_matrix to create the sparse matrix, you can also use csr_matrix instead.\nI have also used svds, which is a function which returns the Singular Value Decomposition matrices given a matrix and is optimised to work on sparse matrices. You can also use truncated_svd in place of it.\nPython  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  import numpy as np from scipy.sparse.linalg import svds from scipy.sparse import lil_matrix class Matrix: def __init__(self, sentences, nlp, word2index, index2word, index, vocab): # Window refers to the window size for calculating co-occurances # K refers to the truncated value of svd we will be taking self.sentences = sentences self.nlp = nlp self.window = WINDOW self.word2index = word2index self.index2word = index2word self.index = index self.vocab = vocab self.k = K def getEmbeddings(self): return self.embeddings def getMatrix(self): return self.matrix def wordEmbeddings(self, word): return self.embeddings[self.word2index[word]] def moveWindow(self, matrix, window, sentences): # Going window to window to increment all co-occuring words for sent in sentences: words = self.nlp(sent) for i in range(0, len(words) - window + 1): for j in range(i + 1, i + window + 1): if j \u0026lt; len(words): i_index = self.word2index[words[i].text] j_index = self.word2index[words[j].text] matrix[i_index, j_index] += 1 matrix[j_index, i_index] += 1 return matrix def getSVD(self, matrix): # Performing Single Value Decomposition on matrix and taking top k columns # The word embeddings is the right matrix, and hence we return only that right, sigma, left_t = svds(matrix, self.k) return right def handle(self): self.matrix = lil_matrix((self.index, self.index), dtype=np.float) self.matrix = self.moveWindow(self.matrix, self.window, self.sentences) self.embeddings = self.getSVD(self.matrix)       'use strict'; var containerId = JSON.parse(\"\\\"960ec73005611366\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } ","description":"Creating Word Vector Embeddings using Co-Occurance matrix and SVD","id":2,"section":"posts","tags":["Python","words","svd"],"title":"Co-Occurance Matrix","uri":"https://aurumnpegasus.github.io/website/posts/cooc_embeddings/"},{"content":"This blog contains an explanation and tutorial of how to reverse very large files in C\nüìú Introduction To understand requiring a different method to read and reverse huge files, one must first understand the standard process. Your system loads the program you want to execute into the RAM, and since you are reading the whole file at once, it loads it into the RAM. Now, in standard systems, RAM is limited to about 4-8 GB; hence, it cannot load the whole file into the RAM at once.\nA simple work-around to this is not to load the file into the RAM at all. If you read everything directly from the disk storage, your program would execute, but it will become excruciatingly slow.\n‚ùì Problem The problem here is that we are given three values: path to the file, number of parts we want to divide the text into and the block we want to reverse. Just for a simple explanation, we will assume that the text length is perfectly divisible by the number of parts given.\nüìï Solution To solve this, instead of trying to either load the whole text into the RAM or not load it at all, we will load it block by block. The text file will remain in the disk, but we will move the cursor so that it loads just X amount of characters into the RAM each time.\nSetup First, we read the given arguments and get our source and destination files ready. It is important to know what each of the flags here do. For a better understanding, refer to its man page.\nC  1 2 3 4 5 6 7 8 9 10 11  // O_RDONLY: Read Only int source = open(value[1], O_RDONLY); // O_WRONLY: Write Only // O_CREAT: Create the file if it does not exist // O_TRUNC: Overwrite the file int destination = open(\u0026#34;output.txt\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); int total_parts = *value[2] - 48; int index = *value[3] - 48;       'use strict'; var containerId = JSON.parse(\"\\\"139b9f88689074dd\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Main Code The star of our show is lseek. It is a system call which repositions the cursor as we want (without loading it into the RAM). Before going into the main logic, we need to define some variables.\nC  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // in the source file, go the end of file and offset by 0  off_t source_size = lseek(source, 0, SEEK_END); // block size  long limit = 1024; // Length of each part of source file  long each_part = source_size/total_parts // Start and ending position of part we need to reverse  long start = (index - 1)*each_part; long end = (index -1)*each_part + each_part // Arrays for storing read and reversed part  char *r = (char *) malloc(limit); char *rev = (char *) malloc(limit);       'use strict'; var containerId = JSON.parse(\"\\\"0ca1f9c6dc3bb6dd\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Now, onto the main logic (which is surprisingly small)\nC  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  for(long i=start+limit; i\u0026lt;end; i+=limit){ // SET the cursor at the position given, which is end - i + start  lseek(source, end -i + start, SEEK_SET); // Read limit number of characters from source and store it into r  // It is important to note that the cursor moves ahead limit amount of times due to reading  read(source, r, limit); // Reverse the read array  for(int j=0; j\u0026lt;limit; j++){ rev[j] = r[limit -1 -j]; } // SET the cursor at the position given, which is i - limit - start  lseek(destination, i -limit -start, SEEK_SET); // Write the number of characters from rev into destination  // It is important to note that the cursor moves ahead limit amount of times due to writing  write(destination, rev, limit); if(i +limit \u0026gt;= each_part){ // This part is left as an excercise, think why this is needed and what will come here  // Also think about better ways to structure the loop so that you do not require this :p  } }       'use strict'; var containerId = JSON.parse(\"\\\"f8541cf910763f3a\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } ","description":"Reversing parts of huge files in C","id":3,"section":"posts","tags":["C","system"],"title":"Reversing Huge Files","uri":"https://aurumnpegasus.github.io/website/posts/huge_files/"},{"content":"This blog contains my walkthrough of the OWASP room in tryhackme while trying to learn more about cyber security. Check out the original room as well here.\nüíâ Injection Task 5: Command Injection Practical What strange text file is in the website root directory? Simply enter\nbash  1  ls       'use strict'; var containerId = JSON.parse(\"\\\"ee26229f30b99501\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nThe console will display multiple file names, out of which the most probably answer is drpepper.txt\nHow many non-root/non-service/non-daemon users are there? Enter\nbash  1  cat /etc/passwd       'use strict'; var containerId = JSON.parse(\"\\\"054051cc2de4cb87\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nThis will list a bunch of users and other information. I will go over it one by one.\nFirstly, the command is used to list the users that are locally stored in the system. The structure of each output is\nuser_name:encrypter_password:user_ID:user_group_ID:full_name:user_home_directory:user_bash_shell\nNow, a normal user has UID $\\geq$ 1000. Hence all the other users are system users. As we can see, all the IDs mentioned are below 1000, hence we get the answer as 0\nRead more about this here.\nWhat user is the app running as? Enter\nbash  1  whoami       'use strict'; var containerId = JSON.parse(\"\\\"f5cd197096ccd9f7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nAs can be seen, the answer is www-data\nWhat is the user\u0026rsquo;s shell set as? Again, enter\nbash  1  cat /etc/passwd       'use strict'; var containerId = JSON.parse(\"\\\"491d9fcf0f00962d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nNow, you look at the user_bash_shell of www-data and we see that the answer is /usr/sbin/nologin\nWhat version of Ubuntu is running? Enter\nbash  1  hostnamectl       'use strict'; var containerId = JSON.parse(\"\\\"da047a34badb3b30\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nIt will display a bunch of information about the OS the server is running on. Answer is 18.04.4\nPrint out the MOTD. What favorite beverage is shown? Thew way I figured out the answer is simply by thinking that the name of strange text file was drpepper.txt. The name fit the answer so well :p\nFor a proper answer which I then googled for:\nEnter\nbash  1 2  ls /etc/update-motd.d/ cat /etc/update-motd.d/00-header       'use strict'; var containerId = JSON.parse(\"\\\"468ff268d0fff87d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nThe last line of the output talks about Dr Pepper hence that is the answer.\n‚õèÔ∏è Broken Authentication Task 7: Broken Authentication Practical What is the flag you find in darren\u0026rsquo;s account? Do as is mentioned, and once you log in you will see the flag fe86079416a21a3c99937fea8874b667\nNow try to do the same trick and see if you can login as arthur Yes, you can\nWhat is the flag that you found in arthur\u0026rsquo;s account? d9ac0f7db4fda460ac3edeb75d75e16e\nü•∫ Sensitive Data Exposure Task 11: Sensitive Data Exposure (Challenge) What is the name of the mentioned directory Since I thought they have mentioned the directory in the source code, I checked it but did not find anything in the main page. Then on going to the Log-In page I found /assets\nNavigate to the directory you found in question one. What file stands out as being likely to contain sensitive data? Go to http://MACHINE_IP/assets/. Here, we can see all the files and directories from which the answer is webapp.db\nUse the supporting material to access the sensitive data. What is the password hash of the admin user? Download webapp.db. Then use the commands\nbash  1  sqlite3 webapp.db       'use strict'; var containerId = JSON.parse(\"\\\"8b4fcc81d3bdfbc9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Once that is done, use the following commands\nsqlite3  \u0026gt; .tables \u0026gt; pragma table_info(users); \u0026gt; select * from users;     'use strict'; var containerId = JSON.parse(\"\\\"96c1827ce685db6c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  The answer is 6eea9b7ef19179a06954edd0f6c05ceb\nCrack the hash. Go to crackstation as mentioned in the material and crack the password. The answer is qwertyuiop\nLog in as the admin, what is the flag? Use the credentials you have, the answer is THM{Yzc2YjdkMjE5N2VjMzNhOTE3NjdiMjdl}\nüö´ XML External Entity Task 13: eXtensible Markup Language Full form of XML Extensible Markup Language\nis it compulsory to have XML prolog in XML documents? no\nCan we validate XML documents against a schema? yes\nHow can we specify XML version and encoding in XML document? XML prolog\nDocument Type Definition (DTD) How do you define a new ELEMENT? !ELEMENT\nHow do you define a ROOT element? !DOCTYPE\nHow do you define a new ENTITY? !ENTITY\nTask 16: Exploiting Try to display your own name using any payload. Enter\nXML  1 2 3 4 5  \u0026lt;!DOCTYPE replace [\u0026lt;!ENTITY name \u0026#34;feast\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;userInfo\u0026gt; \u0026lt;firstName\u0026gt;falcon\u0026lt;/firstName\u0026gt; \u0026lt;lastName\u0026gt;\u0026amp;name;\u0026lt;/lastName\u0026gt; \u0026lt;/userInfo\u0026gt;       'use strict'; var containerId = JSON.parse(\"\\\"cdc911b4fd1cbcf7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  See if you can read the /etc/passwd Enter\nXML  1 2 3  \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE root [\u0026lt;!ENTITY read SYSTEM \u0026#39;file:///etc/passwd\u0026#39;\u0026gt;]\u0026gt; \u0026lt;root\u0026gt;\u0026amp;read;\u0026lt;/root\u0026gt;       'use strict'; var containerId = JSON.parse(\"\\\"1e44a2aae9e82b95\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  What is the name of the user in /etc/passwd? This can be determined by the output of the previous question. The answer is falcon\nWhere is falcon\u0026rsquo;s SSH key located? This was fairly simple to do. It is known that ssh keys are stored in either .ssh/id_rsa or .ssh/id_rsa.pub based on whether you need public or private key. As the next question asks for private key, we get the answer as /home/falcon/.ssh/id_rsa\nWhat are the first 18 characters for falcon\u0026rsquo;s private key? Simple enough, just use the location mentioned in previous answers and cat the file. Answer is MIIEogIBAAKCAQEA7\nüõÇ Broken Access Control Task 18: IDOR Challenge Look at other users notes. What is the flag? There are better methods to do thus (using Burpsuite) but since I did not know about it when I started this challenge, I just had to luck out by getting the answer at note=0\nüîê Security Misconfiguration Task 19: Security Misconfiguration Hack into the webapp, and find the flag! So the first thing I did was go through the source code, but I couldnt find any comment of sorts there. Next, I thought to check it out in exploit db, but there too I did not get a good answer. I googled about then I found out that the answer was mentioned in its github page\n‚öîÔ∏è Cross-site Scripting Cross-site Scripting Craft a reflected XSS payload that will cause a popup saying \u0026ldquo;Hello\u0026rdquo; The answer is simple enough\nHTML  1  \u0026lt;script\u0026gt;alert(\u0026#39;Hello\u0026#39;)\u0026lt;/script\u0026gt;       'use strict'; var containerId = JSON.parse(\"\\\"3431211c50fd6ef3\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  On the same reflective page, craft a reflected XSS payload that will cause a popup with your machine\u0026rsquo;s IP address. Google around the command to display your machines IP address in JS, after which enter\nHTML  1  \u0026lt;script\u0026gt;alert(windows.location.host)\u0026lt;/script\u0026gt;       'use strict'; var containerId = JSON.parse(\"\\\"13304feebad7bb60\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Then add a comment and see if you can insert some of your own HTML You can enter any HTML code you want.\nHTML  1 2 3 4 5  \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; Hi \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;       'use strict'; var containerId = JSON.parse(\"\\\"6ab1802a17c46e32\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  On the same page, create an alert popup box appear on the page with your document cookies. Again, google around on how to display cookies in JS, then just write down the command:\nHTML  1  \u0026lt;script\u0026gt;alert(document.cookies)\u0026lt;/script\u0026gt;       'use strict'; var containerId = JSON.parse(\"\\\"f50bbc22c822e8ab\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Change \u0026ldquo;XSS Playground\u0026rdquo; to \u0026ldquo;I am a hacker\u0026rdquo; by adding a comment and using JS. Go to the source code and figure out the document id of the element which has the title stored. Then use simple JS to change the heading (or use the hint :p)\nHTML  1  \u0026lt;script\u0026gt;document.querySelector(\u0026#39;#thm-title\u0026#39;).textContent = \u0026#39;I am a hacker\u0026#39;\u0026lt;/script\u0026gt;       'use strict'; var containerId = JSON.parse(\"\\\"86247dfb34f27e8e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  üìÇ Insecure Deserialization Task 21: Insecure Deserialization Who developed the Tomcat application? Google around, I initially got the answer as a single person who was responsible for it, but then you get The Apache Software Foundation\nWhat type of attack that crashes services can be performed with insecure deserialisation? DOS, or Denial of Service\nTask 25: Cookies Practical 1st flag (cookie value) Follow the instructions mentioned in the text. The cookie value is base64 encoded, hence just use a normal base64 decoder to get the value of the cookies\n2nd flag (admin dashboard) Simply change the value of userType=\u0026quot;admin\u0026quot;.\nüóÉÔ∏è Components with Known Vulnerabilities Task 29: Lab How many characters are in /etc/passwd Go to exploit DB and see if you can find any exploits for CSE Bookstore or projectworld which will give us remote shell access. As we can see, there is one.\nNow, we just download them and run the script to execute it. There is sufficient documentation to know how to execute the command\nbash  1 2  python3 47887.py http://machine_ip/ wc -c /etc/passwd       'use strict'; var containerId = JSON.parse(\"\\\"b345b4032e4dae3d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  üñ•Ô∏è Insuffecient Logging and Monitoring Task 30: Insuffecient Logging and Monitoring What IP address is the attacker using? Look at the IP adress which is used the most and is unauthorised. As can bee seen, the answer is 49.99.13.16\nWhat kind of attack is being carried out? From what can be seen, different usernames are used in each request. Also, using the hint, we can find out that the answer is Brute Force\n","description":"Solving the OWASP top10 room from tryhackme","id":4,"section":"posts","tags":["room"],"title":"OWASP top10","uri":"https://aurumnpegasus.github.io/website/posts/owasp/"},{"content":"This blog talks about the structure of OSI model, and how data is sent across computers.\nüè∞ OSI Model The OSI Model (Open Systems Interconnection Model) is a conceptual framework used to describe the functions of a networking system. It defines rules and requirements that support effortless data transfer between different products and software. In the OSI reference model, the communications between a computing system are split into seven different abstraction layers: Physical, Data Link, Network, Transport, Session, Presentation, and Application.\n üß≠ Application The Application layer is the OSI layer closest to the end-user. In this layer, the user connects to the network via software that uses the internet, like Chrome, Firefox, MS Suite. It is important to note that these applications do not reside within the application layer. Instead, the application layer defines protocols (or rules) for the functioning of these applications.\nSome examples of the protocols defined are:\n FTP: Used for file transfers HTTP/S: Used for web surfing SMTP: Used for emails Telnet: Used for virtual terminal.  When data is given to the Application layer, it is passed down into the Presentation layer.\nüìë Presentation The Presentation layer receives data from the Application layer and converts it into machine language. It has three main tasks:\n Conversion: Converts the machine-specific data from the Application layer into a standardised format that the application layer could understand in the receiving computer. Compression: Often, the binary code after conversion is too large. It is then compressed to reduce the memory it takes. Encryption: As an additional layer of security, the compressed data is then encrypted using SSL (Secure Sockets Layer).  After these three tasks are done, the data is then transmitted to the Session layer. \\\n‚òéÔ∏è Session The Session layer controls the conversations between different computers. On receiving the data, it looks to connect with the other computer across the network. If it can not be done, then it returns an error message. If a session can be established, the Session layer is in charge of maintaining it. The Session layer also needs to co-operate with the Session layer of the other computer to synchronise communications. Once communication is over, the Session layer terminates the connection as well.\nThe Session layer creates unique sessions per communication request, due to which you can make multiple requests to different endpoints simultaneously (multiple tabs on a browser).\nOnce we get the data from the network, it is converted into data packets and sent to the Transport layer.\nüöö Transport The Transport layer receives data packets from the Session layer and chooses the protocol over which the data is to be transmitted.\n TCP: Transmission Control Protocol. It is connection-based transmission, which means that connection between the computers is established and maintained throughout the request. These layers are slower since it has a feedback mechanism. Via the feedback, it is ensured that the lost/corrupted data can be retransmitted. It is generally used for EMails, Loading Webpage, File Transfer. UDP: User Datagram Protocol. It is connectionless transmission, where there is a high chance of data being lost. It is up to the receiving computer to keep up with the data which is sent. In this case, data transportation is faster, but due to the lack of feedback mechanism, loss/corrupted data cannot be regained. It is generally used for Video Streaming, Calls.  The Transport layer divides the data into bite-sized pieces, where each piece contains a Source and Destination Port Number and Sequence Number.\n Port Number: Used to direct each segment to the correct Application Sequence Number: Used to reform the whole message in the correct order.  These bite-sized pieces are called Segments if using TCP and datagram if using UDP. They are then sent to the Network layer.\nThe Transport layer is also in charge of flow control. If the server sends data at a higher rate than our machine can handle, it communicates and asks to send data at a lower rate. If the server sends data at a lower rate, it communicates to send data faster. In TCP, if data is corrupted, it uses Automated Repeat Request to restore the data.\nüì¨ Network The Network layer is responsible for locating the destination of your request. The network layer takes the IP address (if you want to request information from a webpage) for the page and figures out the best route to take.\nLogical Addresses (here, IP Address) are used to provide order to networks, categorising them. Each segment is assigned a sender and receiver IP address, which is called a packet. These packets travel through the network.\nThe process of moving data packets from source to destination is called routing.\nüí≥ Data-Link Data packets are sent from the Network layer to the Data-Link layer. The Data-Link layer adds a MAC (Media Access Control) Address to each packet for sender and receiver to make a Frame. Inside every network-enabled computer is a NIC (Network Interface Card) that comes with a unique MAC.\nThe Data-Link layer serves another essential function. It checks if the received information is corrupted during transmission or not.\nüß∞ Physical The lowest layer of the OSI Model. The Physical layer receives data from the Data-Link layer as frames and converts them into binary format. Once it is converted into binary, it is then transmitted as electrical pulses.\nüì≤ Receiving When the second computer receives the message, it reverses the process. It starts at the physical layer and sends the data up to the application layer, stripping the added information (de-encapsulation) as it goes up.\n üìù References  TryHackMe Introductory Networking OSI Model Explained by TechTerms ","description":"How computers send data across networks (OSI model).","id":5,"section":"posts","tags":["network"],"title":"Networks","uri":"https://aurumnpegasus.github.io/website/posts/networks/"},{"content":"This blog contains explanation of the paper by Victor Allis called \u0026lsquo;A Knowledge-based Approach of Connect-Four\u0026rsquo;\nüìú Introduction Connect-Four is a game for two players. Both have 21 identical coins. In the standard form of the game, one set of coins is yellow, and the other is red. You play the game on a vertical, rectangular board consisting of 7 vertical columns of 6 rows each. Each time a player puts a coin down, it falls to the lowest unoccupied block in that column. Players make a move in turns.\nIf a player connects four coins either horizontally, vertically or diagonally, they win. Occupying each of the 7x6 blocks such that no other move is possible, and ensuring that there is no winning player, entails the draw condition.\nNow, some definitions to make referencing the board easier. The 7 columns are labelled \u0026lsquo;a\u0026rsquo; through \u0026lsquo;g\u0026rsquo;, while the rows are numbered 1 through 6. In this way, the lowest square in the middle column is called d1. For convenience\u0026rsquo;s sake, we are taking the first player as White (W) and second as Black (B) (similar to Chess).\nüõ£Ô∏è Approaching the Game Before you show off your excellent techniques, we need to first prove that the dumb approach does not work. It is easy to see that the number of possible positions is at most $3^{42} (\\geq 10^{20}).$ This upper bound is a very crude one and can be brought into better proportions. For this purpose, a program was written in the C programming language, which is mentioned later. For the standard, 7 x 6 board, the program saw an upper bound of $7.1* 10^{13}$.\nSo, too many possibilities, significantly less accuracy, brute force is not an efficient approach. A player cannot win just by instantiating each possible board and trying to follow it. You are a human after all, not a computer üòõ\n‚öÑ Some Possible Boards Let\u0026rsquo;s start small. Consider a board of n columns, but only 2 rows. My claim is that Black will never lose a game on this board. Even if n were to be practical infinity.\nThis is how B should play:\n Pair up all the n rows in groups of 2. If n is odd let the nth row be alone. If W plays in row 1, play in row 2 (pair). If W plays in row 2, play in row 1. If W plays in row N, play in row N.  This will always result in a draw, since only way W could win is if it were to get its coin in 4 consecutive rows side by side. This is prevented by B.\nAnother solved board is with 2n rows (even) and columns ‚â§ 6. This strategy could also be used for ensuring B always draws.\n If W plays in columns 1, 2, 5 or 6, B plays in the same column. If W plays for the first time in column 3 or 4, B plays in the other column. Otherwise, if W plays in column 3 or 4, and B can still play in it, B plays in the same column If W plays in column 3 or 4, and B can not play in it, B plays in the other column.  Since B never allows a vertical 4 for W, that is out of the question. For horizontal 4 at row 1, B ends up occupying at least 1 of the two bottom columns, hence denying that for W as well. For any other horizontal 4, it is only possible in odd rows for W. But in column 3 and 4, B ends up having at least 1 in either of the two in all odd rows. Diagonal is not possible at all since W will have all coins at odd rows in column 1, 2, 5 and 6.\n‚ò†Ô∏è Threats Useless Threats  The threats by W in row 3,4,5 are considered to be useless, due to the threat by B in row 2. Since W cannot move in column 2 and 6, it has to fill column 7. Even number of rows mean that W will still have the turn when column 7 is filled, meaning B will end up winning.\nWhether a threat is useless or useful is dependant on control of Zugzwang (explained later).\nOdd Even Threat A threat is only useful if a player is forced to play in a row just below that of the threat. Usually that happens when other columns are filled. In such cases, generally, W has only odd rows, and B has even rows.\nBlack has odd threats, and White has even. If they are in the same column, the lower threat will win (as seen above)\nGenerally speaking, W threat is stronger than that of B. Here is how everything rolls out:\n W has odd, B has even threat: W will win. W has even, B has even threat: B will win. W has even, B has odd threat: Draw. W has odd, B has odd threat: Draw.\nA simple example consisting of multiple threats is:   Here, B has odd threat at c3 and W has odd threat at f3. Going by the table, it should be a draw. Lets play it out. W has to give up its own threat to play the game, which would ideally result in a draw, since B will have to give up its threat in c. But what happens is that B gets to create a new threat at c2 due to coin at f5. This gives B consecutive threats, and thus it wins.\nThis tells us that though parity of threats tells us a good amount about the winner, we need to be careful about new threats.\n‚ùÇ Zugzwang This is a very basic but powerful concept in Connect 4. Zugzwang basically means to force a player to make a move they would rather not make. This is due to the simple rule that they have to make a move, and the constraints of the board.\nInitial Position W always moves first. Therefore B always is in a position to play follow up, hence to control the Zugzwang. Suppose B plays follow up from the beginning, you would end up with a board like this:\n Though this is an illegal position, it is interesting to note who won first. Since W controls whole first row, naturally W won the game first. This shows that follow up is not a good strategy at the start of the game for B.\nOther Positions The following board represents a position where W is in control of the Zugzwang:\n Here, W has an odd threat in column a. Knowing this, B won\u0026rsquo;t play there. Since on the rest of the board, odd number of squares are remaining, whoever plays first here, the opposite will have to play in column a. Since W is playing the first, it can control the zugzwang to force B to play at a2. The only option B has to go against the zugzwang and connect its 4 men, but still, it is W\u0026rsquo;s game to lose.\nIn this case, B has control of Zugzwang due to even threats\n B and W ideally do not want to be the first to play in b or f. Other than these 2, the total number of boxes remaining is even. This means whoever plays first here, will be the player *forced to play first in either column b or f. That means at the end, W will have to play in b1 or f1, thus losing. B is in complete control of Zugzwang here and can play follow up\n üìù References  Resources by Victor Allis Alpha Beta Pruning based heuristics Principles and Tehniques BY Stanford C4 Numbers by oeis org Math oriented resources behind Connect-4 ","description":"Exploring the paper by Victor Allis on how to view the game.","id":6,"section":"posts","tags":["paper","connect4"],"title":"Connect Four, Part-1","uri":"https://aurumnpegasus.github.io/website/posts/connect_four_1/"},{"content":"This blog contains explanation of the paper by Victor Allis called \u0026lsquo;A Knowledge-based Approach of Connect-Four\u0026rsquo;\nThis is a 2 part series exploring the paper, and I would suggest going through \u0026lsquo;first part\u0026rsquo; if you haven\u0026rsquo;t already.\nüïµÔ∏è‚Äç‚ôÇÔ∏è Strategies A formal definition is given of the nine rules which are used to refute potential threats of the opponent. These can be only applied by the player in control of the Zugzwang. These are always applied in the places opponent has to move.\nClaimeven This makes direct use of the fact that player in control of Zugzwang can get all even unclaimed positions, giving odd positions to the other.\n B is in control of Zugzwang here since W doesn\u0026rsquo;t have any threat. Here, if B were to use claimeven, he could end up getting a draw, since any threat of W will need to have a coin in even row, which will not be possible.\nBaseinverse This is based on the logic that a player cannot play two directly playable moves in one turn. Therefore once the opponent has made the move, controller of Zugzwang can still cover the other position.\n Here, if W cannot play in a1 and b1 at the same time. That means if W plays in a1, B plays in b1, and vice versa. Thus the threat is nullified.\nVerticle Similar to Baseinverse, this is based on the fact that a player cannot play two directly playable moves in a single column in one turn. Depending on the opponent, the player controlling the Zugzwang can either play second or first in the column to prevent a verticle 4.\nAftereven Aftereven uses a special side-effect of the usage of one or more Claimevens. If a group can be completed by the controller of zugzwang, then they can complete the whole board using claim even, and then complete that group:\n Here, B can use aftereven to complete the group at either b2 or f2. Here, then B can use claimeven to finally force W to play in either b1 or f1. This is called as aftereven, where you can form a group and win by using claimevens.\nLowinverse Lowinverse is based on the fact that two odd numbers when summed give an even number. Normally, controller of Zugzwang will play lowest even square of the column containing odd number of empty squares. But when we have two columns (doesn\u0026rsquo;t have to be consecutive) having odd number of empty squares, this will force the opponent to play first. In such a way controller of zugzwang gets to take the odd square above the opponent.\nHighinverse This is based on the same principle as that of lowinverse:\n In lowinverse, we would consider c2, c3, d2, d3 as important. Here we consider c4 and d4 as important too. Highinverse is nothing but a combination of lowinverse and claimeven. What this does is say W plays in c2, then using lowinverse B can get c3. Then B (controller of Zugzwang) convert d3 and d4 into a claimeven, to get d4. In such a way B ends up getting c3 and d4.\nBaseclaim This is a combination of Baseinverse and Claimeven:\n Here, W can possibly have 3 threats formed: b1-e1, c1-f1, b1-e4(diagonal). B needs to play in a way to counter this.\n W plays in b1, B plays in e1 and then uses Claimeven at c1-c2 to prevent b1-e4. W plays in c1, B plays in e1 and then uses Claimeven at b1-c2 to prevent b1-e4. W plays in e1, B plays in c1 and then uses Claimeven at b1-c2 to prevent b1-e4.  In such ways B can nullify all of W\u0026rsquo;s threats.\nBefore This is a combination of Claimeven and Vertical:\n Here b4-e1 is the Before group. Since b4 and e1 are still empty, this means it works for all groups needing both b5 and e2 (b5-e2). Here, before uses the squares b4-b5 and e1-e2. As soon as b4 is played, b5 is played, and same with e1-e2. This will ensure B completing b4-e1 or preventing W\u0026rsquo;s b5-e2. In both cases b5-e2 is a useless threat.\nIt basically means that if there is a before group, the opponent cannot claim all the unclaimed squares in the threat column.\nSpecial Before  We use d2-g2 as the before group. This can contain claim evens at f1-f2 and g1-g2 and vertical at e2-e3. We need to use baseinverse to solve a1-d1, which would give W a possibility of b1-e4. To combat this, we can use claimeven to get e4. This claimeven, however, is conflicting with vertical at e2-e3.\nThe only reason B needs to play e3 is to prevent d3-g3. So B can play d3 as well. If W were to play at d3 before, then B should immediately get e2 to continue with the Before play. Therefore to play a Special Before, we need a before group (d2-g2) with one of the empty squares as directly playable (e2). Furthermore, we need another playable square (d3).\nCombination  ‚ö´‚ö™ Black and White Black We have developed a set of rules which can be used to show that certain potential threats can be refuted. Since some of the rules depend on Zugzwang, it is important that the person who applies them is in control of the Zugzwang.\nB is in control of Zugzwang until W creates an odd threat. Till then if B just plays using the strategy. If W were to create a good threat (odd threat), B is no more in control of Zugzwang. Here we observe that no matter what B does from here on out, there generally will not be any set of rules which can refute that threat.\nFrom this we can conclude that we do not need to check who controls the Zugzwang for B before applying the rules. For if B is in control, we can apply the rules, if not, it doesn\u0026rsquo;t matter what B does.\nWhite W needs an odd threat to gain control of Zugzwang. Once it has that, he just needs to follow the strategic rules to fill up the rest of the board. If W has more than one odd threat, it can choose from which poison to kill B from.\nVictor A position in which W has to move, can be evaluated as B as controller of Zugzwang, and vice versa. For W as a controller of Zugzwang, evaluation must be done removing the odd column out of viable options. The evaluation begins with finding all possible instances of the 9 strategic rules.\nFor each position where any rule is applied, it is seen whether it can solve a problem or not. Each application of one of the rules which solve one or more problems is stored. These are called Solutions. This results in a list of solutions, where each solution is stored as a Struct. Struct consists of fields describing the rule, and the positions involved. Furthermore for each solution we have a list of groups solved by that solution.\nWe also create a map with problem as the key and list of pointer(s) to the solution as the values. After all this, we need to see which solutions can work together and which cannot. To work this out, solutions are seen as nodes of an undirected graph. If two solutions can\u0026rsquo;t be used simultaneously, they are connected. These connections are stored in an adjacency matrix. To fill it, it is important to know type of solutions and squares involved. Once it is filled, it is a normal square array.\nIf we see the problems as nodes, too, and we connect a solution and a problem if the solution solves the problem, and no problems are connected, we can solve it as a pure graph problem.\nGiven are two sets of nodes, S(olutions) and P(roblems). We try to find an allowable (in graph theory: independent) subset C(hosen) of S, with the property that P is contained in B(C) (the set of all neighbours of nodes in C)\nIt can be solved using a simple backtracking algorithm.:\ncpp  1 2 3 4 5 6 7 8 9 10 11 12 13  void FindChosenSet(P, S) { if (P == EmptySet) { Eureka(); // We have found a subset C  } else { MostDifficultNode = NodeWithLeastNumberOfNeighbours(P); for (auto neighbours: MostDifficultNode) { FindChosenSet( P - { MostDifficultNode }, S - AllNeighboursOf(ChosenNeighbour) ); } } }       'use strict'; var containerId = JSON.parse(\"\\\"09b674dbfe5a3a4c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  If a set of solutions is found for a given position, these solutions show the plan which has to be followed to play the game until the desired result (win for White, or at least a draw for Black) is reached.\nüß† Food for Thought Lets assume we have an oracle. This oracle cannot predict who will win, but for any given state of board, give the best possible outcome. Let us assume that we play such that for each state of board, we ask for help from the oracle. Therefore it is a \u0026lsquo;perfect\u0026rsquo; game. In such case, if W wins, does that mean W will always win if it were a perfect game?\nThe thing is, if for B we were to choose that draw is fine, it will not change any result. Since oracle predicts the best move, if the second scenario gives different result, that would mean Oracle could have chosen the best move, but did not. That is contradictory. That means that whoever will win with the help of the Oracle, is always at an advantage.\nAnother thought to explore is number of legal ways to arrange $N$ coins in board. For now, we take the board to be the standard $7 \\times 6$ board.\n üìù References  Resources by Victor Allis Alpha Beta Pruning based heuristics Principles and Tehniques BY Stanford C4 Numbers by oeis org Math oriented resources behind Connect-4 ","description":"Exploring the paper by Victor Allis describing strategies in the game.","id":7,"section":"posts","tags":["paper","connect4"],"title":"Connect Four, Part-2","uri":"https://aurumnpegasus.github.io/website/posts/connect_four_2/"},{"content":"This blog contains an explanation of the paper \u0026lsquo;The complexity of Scotland Yard\u0026rsquo; by Merlijn Sevenster.\nThis is part 1 of a two part blog. Part 1 explains the game, and lays out the foundations required for formalisation of the game. It also lists out the various assumptions we are going to consider in the game.\nThe blog was originally published on \u0026lsquo;GameLab\u0026rsquo; for our course project. The website also contains additional information about heuristics used in Scotland Yard, and similar analysis for other board games.\nüìñ Introduction Scotland yard is a popular board game, named after Scotland Yard, the headquarters of London\u0026rsquo;s Metropolitan Police Service. It is played by 2-6 players in which one of the players is the criminal (Mr. X) and the remaining are detectives. As is intuitive, the objective of the game for the detectives is to catch the criminal, while the objective of the criminal is to run away from its pursuers for 22 rounds. It is an asymmetric board game since the players do not have the same goal.\nüìú Rules Let\u0026rsquo;s take a look at the rules once, before we jump into analysing the game.\nMovement of players: Each detective and the criminal is assigned a pawn to mark their position on the board. There are a total of 199 positions on the Scotland Yard board. Each position can represent 1-3 stations, a taxi, a bus, and an underground route, which is marked by a number and the colour of the station it represents.\nEvery station on the map can be reached with the taxi (yellow). However, the distance that you can travel is short: You can only move (along the yellow line) to the next station.\nThe bus (turquoise) only drives from stations with a turquoise semi-circle; a bus will take you a little further than the taxi (along the bus line).\nThe underground (red) travels along the red line and covers the furthest distances the quickest. However, there are only a few underground stations (stations with a red inner rectangle) on the map.\nAll playing pieces can only be moved to unoccupied stations. If there are no unoccupied stations for Mister X to travel to, he has lost the game. Mister X also loses if one of the detectives moves to the station where Mister X is located.\nScotland Yard Map   Tickets Each detective receives ticket cards that allow him to across the board. At the start of the game, each detective gets 4 underground tickets, 8 bus tickets, and 11 taxi tickets, and each detective receives 5 black tickets and 2 double move tickets.\nIn each round, after a detective has used up a ticket to travel to another position, they cannot use them again, however, this ticket is now available for Mr. X\u0026rsquo;s use. If a detective no longer has any tickets or can\u0026rsquo;t move from his current station with the tickets he has left, they have to sit out.\nA black ticket allows Mr.X to hide the route he used and also travel by ferry (a route only he is allowed), and a double move ticket allows him to make two moves to two different stations in one round.\nInitial Starting Position To determine each player‚Äôs starting position, a set of start cards marked D and X are shuffled separately and each detective selects from the D cards and places their playing piece on the respective position. Mr. X picks an X card but doesn‚Äôt reveal his position to the detectives or place his playing piece on the board.\nGameplay In total, 22 rounds are played. In each round, Mr. X first makes their move, concealing his new position from the remaining players, and writes down the station he moved to on a paper, hiding the station with the ticket they used. (The detectives can see which mode of transport Mr.X has used.)\nWhen a detective makes a move, the used-up ticket is placed in the general draw pile where Mr. X gets his tickets (so Mr. X basically has an unlimited number of tickets).\nMoving Mr. X Each turn Mr. X conceals his move. However, there are special moves (3rd, 8th,13th, 18th, and 24th moves) where Mr. X must surface. He has to reveal his current position before moving to a new station, which gives detectives the chance to co-ordinate and corner the criminal!\nMoving the Detectives The detectives use their tickets to move around the board. If they run out of tickets or don\u0026rsquo;t have the required ticket to move out of a station, they must sit out of the game. Detectives can\u0026rsquo;t trade tickets among themselves and all their remaining tickets have to be visible to Mr. X, so he can see the remaining means of transportation they have left.\nWinning the Game Mr. X wins if -\n He is able to move around the board for 22 rounds without being caught.  The detectives win if -\n They corner Mr. X (he has no stations to go to where a detective is not present) They move to a station where Mr. X is currently  Now that we understand how to play, let\u0026rsquo;s dive into different aspects of the game!\nüéØ Objective The goal of this page is to analyze the game Scotland Yard.\nWe start off by venturing into proofs for Scotland Yard being a PSPACE problem and the similarities between Scotland Yard and a game of perfect information. It is easy to feel daunted by these claims, trust me I felt it too. To make it easier, we remove all the layers of abstraction from the game first. We convert the game into a problem of Groups, Graphs, and Sets.\nIt is understandable if you think it still is going to be tough. We ensure that you will understand what these jargons are and how they interact with the game itself. We firstly introduce Games with the viewpoint of perfect and imperfect information. Then we connect Scotland Yard to that idea and remove all the layers of abstraction. Once that is done, we proceed with proofs.\nüèóÔ∏è Laying the Foundation To properly explain some concepts, we need to define some terms:\nExtensive Games: Games that allow the representation of various key aspects. These aspects include a set of players, each player\u0026rsquo;s moves, their decisions, the information (possibly imperfect) about a player, and their payoffs for all possible outcomes. Essentially, they are games that can be represented with a game (decision) tree.\nPerfect Information Game: In a perfect information game, a player has complete information about all events which have previously occurred in the game.\nImperfect Information Game: Games which have some aspects of the game hidden are called imperfect information game.\nIt is easily understandable why Scotland Yard comes under the bracket of the extensive game with imperfect information. For it to be an extensive game, it should formally represent each and every aspect of the game, which is the moves and mode of commutation each player uses. Even if the moves are hidden, they are definite and are represented. Since the moves are hidden, it is impossible for the detectives to know which route the criminal has taken, which makes it an imperfect information game.\nNow, let\u0026rsquo;s look into some abstraction or representations.\nAny win-loss game $G$ with perfect information can be represented as a 4-tuple\n$$G = \u0026lt; N, H, P, U\u0026gt;$$\n $N$: Represents the number of total players. $H$: Is a set of histories. A history ($h$) represents a given state of the board at some point in time. Every $h = \u0026lt;a_1, a_2, . . a_p \u0026gt; $, where $a_i$ is an action. Each history is an ordered list of actions. $h'$ = $\u0026lt;h, a'\u0026gt;$ represents the immediate successor of $h$, where $h'$ = $\u0026lt; a_1, a_2 . . . a_p, a'\u0026gt;$. There are two types of history, terminal ($Z$) and non-terminal ($H-Z$). Terminal represents an end condition, after which no other action can be taken. A history becomes terminal when a player wins. $P$: Is the player function. It assigns to each non-terminal history a particular player. Formally, we define it as $P:$ { $H - Z$ } $\\rightarrow N$. We say that a history $h$ belongs to $P(h)$, essentially when the last action in the set of actions that is $h$ is made by the player. $U$: Is the utility function, assigning each terminal history to a player. (the player has won the game). The formal definition would be $U: Z \\rightarrow N$  Given $G$ defined as above, a function $S$ is called a strategy for a player $\\space i \\in N i‚ààN$ if it maps for every history $h$ belonging to $i$ to an action $A(h)$.\nAn extensive game with imperfect information extends a game with perfect information. To represent the former, all you need is to add is an Information function in the original tuple.\n$$G = \u0026lt; N, H, P, \\langle \\mathcal{I}_i \\rangle _{i \\in N}, U \u0026gt;$$\nThe only difference in this is that $\\mathcal{I}_i$ carries information sets for each $i \\in N$. $\\mathcal{I}_i =$ {$I_1, I_2, . . . I_q$}. where each $I$ represents a set of histories, there having been $q$ rounds of the game played so far. Each $I$ basically is a set of histories (or state changes of the board) of that round (till $i$ makes an action again). Intuitively, an extensive game with imperfect information models the situation in which player $i$ knows that some history $h \\in I \\in \\mathcal{I}_i$ has happened, but there are unable to tell hh apart from the other histories in $I$.\nIn simple terms, they know other players have made a move based on the last action they took, but are not completely sure of the previous actions the player took.\nA function $S$ is called a strategy for a player $i$ in $G$ if it maps every information partition $I \\in \\mathcal{I}_i$ belonging to $i$ onto action in $A(I)$\nAssumptions for Mathematical Modelling For convenience, there are some assumptions which have been taken.\n There is only 1 mode of transport, that is Taxi. The same method described as follows can be easily translated with more modes of transport. A player will have $k$ amount of tickets of Taxi, where $k$ = number of rounds. There are only two players, Detective and Mr X. Only 1 player will be controlling all detectives. Value of $k$ will be always $\\leq |V|$, where $V$ is the number of nodes in the graph. We have used digraph to represent the game board. Mr. X will always play the first move in each round. Mr. X will be considered to be caught IF AND IF ONLY it is on a node occupied by a detective at the END of the round (after detectives have moved). Mr X will win if and if only the game goes on for $\u0026gt;k$ rounds, otherwise Detectives have won.  üìù References   P. Nijssen and M. H. M. Winands, \u0026ldquo;Monte Carlo Tree Search for the Hide-and-Seek Game Scotland Yard,\u0026rdquo; in IEEE Transactions on Computational Intelligence and AI in Games, vol. 4, no. 4, pp. 282-294, Dec. 2012, doi: 10.1109/TCIAIG.2012.2210424.\n  Sevenster, Merlijn. (2006). The complexity of Scotland Yard. Journal of Pharmacology and Experimental Therapeutics - J PHARMACOL EXP THER.\n ","description":"Proving that Scotland Yard is of P-Space complexity.","id":8,"section":"posts","tags":["paper","scotland yard"],"title":"Scotland Yard: Part 1","uri":"https://aurumnpegasus.github.io/website/posts/scotland_yard_1/"},{"content":"This blog contains an explanation of the paper \u0026lsquo;The complexity of Scotland Yard\u0026rsquo; by Merlijn Sevenster.\nThis is part 2 of a two part blog. Part 1 explains the game, and lays out the foundations required for formalisation of the game. It also lists out the various assumptions we are going to consider in the game. Part 2 formalises the game and proves that it is of PSPACE complexity.\nThe blog was originally published on \u0026lsquo;GameLab\u0026rsquo; for our course project. The website also contains additional information about heuristics used in Scotland Yard, and similar analysis for other board games.\nü§µ Formalisation We now know how to formalise any given perfect or imperfect information game. Now let\u0026rsquo;s connect it to the game Scotland Yard.\nLet $SY$ = $\\langle G, \\langle u_* \\overrightarrow{v_*} \\rangle, f \\rangle $ be a Scotland Yard instance. Then, let the extensive Scotland Yard game constitute by $\\mathcal{SY}$ be defined as the tuple\n$$ \\mathcal{SY}(SY) = \\langle N, H, P, \\bullet, U \\rangle $$\nHere,\n  $G$ represents a digraph\n  $u_*$ represents the position of Mr X.\n  $\\overrightarrow{v_*}$ is $n$ dimensional vector, where $n$ is the number of detectives. Each element in the vector represents the initial node of the detective.\n  $f$ is a function which when fed a number (no. of rounds) chooses one of the two elements from the set { $show, hide$ }. This denotes whether Mr X needs to show their position or not.\n  $N$ represents total number of players. For convenience, $N =${$\\forall, \\exists$} where $\\forall$ represents Mr X and $\\exists_1, \\exists_2 . . \\exists_{N-1}$ represent the detectives.\n  $H$ represents a set of histories. Let $\\prec$ be the immediate successor relation on $H$ . So you can say that $\\langle h \\rangle \\prec \\langle h, u \\rangle$ where $\\langle h \\rangle, \\langle h, u\\rangle \\in H$\n  $P$ represents the player function. Due to notational convenience, it is easy to assign the value of the player function. $P(\\langle h, u \\rangle) = \\forall P$ and $P(\\langle h, u , \\overrightarrow{v} \\rangle ) = \\exists$ no matter $u$ or $\\overrightarrow{v}$\n  $\\bullet$ is the indistinguishability relation. It is defined on the group $H$. For any two histories $h, h' \\in H$ where the length of both histories is equal, $h \\bullet h'$ when:\nIf $h = \\langle u_* , \\overrightarrow{v_*}, u_1, \\overrightarrow{v_1}, . . . u_i, \\overrightarrow{v_i} \\rangle$ and $h' = \\langle u_* , \\overrightarrow{v_*}, u'_1, \\overrightarrow{v'_1}, . . . u'_i, \\overrightarrow{v'_i} \\rangle$ then\n $\\overrightarrow{v_j} = \\overrightarrow{v'_j} \\space \\forall \\space 1 \\leq j \\leq i$ and $u_j = u'_j \\space \\forall \\space 1 \\leq j \\leq 1$ such that $f(j) = show$    $U : Z \\rightarrow $ {$win,lose$} is the utility function which determines whether $\\exists$ won or not.\n  $$ U(\\langle h, u, \\overrightarrow{v} \\rangle) = \\begin{cases} win, \\space \\space u\\in \\overrightarrow{v} \\\\\\ lose, \\space \\space u \\notin \\overrightarrow{v} \\end{cases} $$\nIt is easy to see that the operation $\\bullet$ is Equivalent to the group $H$. We write $\\mathcal{H} \\subseteq \\wp(H)$ for the set of equivalent classes, or information cells, in which $H$ is partitioned by $\\bullet$.\n$\\mathcal{H} = \\{ C_1, C_2 . . . C_n\\}$ where $H = C_1 \\cup C_2 . . \\cup C_m$ for every $1 \\leq i \\leq m$, if $h \\bullet h'$ where $h, h' \\in C_i$.\nWe lift the relation $\\prec$ to $H$, using the same symbol: For any pair $C, C' \\in H$ we write $C \\prec C'$ if there exists histories $h \\in C$ and $h' \\in C'$ such that $h \\prec h'$\nWe can also extend this as if $h, h' \\in C$ and $C \\in H$, then $P(h) = P(h')$. Thus the player function is meaningfully lifted as follows: if $C \\in H$ and $h \\in C$, then $P(C) = P(h)$.\n Consider an example game $G^x$. Let $f^x$ be the information function where $f^x(1) = hide$ and f^x(2) = show. Let $u_*$ and $v_*$ as the initial position of $\\forall$ and $\\exists$. Consider that number of detectives to be 1. Let\u0026rsquo;s play this game.\nThe set of histories we can get from this game are:\n where ! marks terminal histories. To reflect that this is a game of imperfect information, we can write $\\mathcal{H}$ as\n A graphical representation of this would be:\n Perfect Information Scotland Yard So, Perfect Information means that each and every aspect of the game is explicitly expressible. The only difference we need to model here is $\\forall$\u0026rsquo;s whereabouts. Since describing each position will convert Scotland Yard into a simple game of Cops and Thieves, we don\u0026rsquo;t do that. Instead, to preserve the game, we describe the position of $\\forall$ as a set of possible nodes.\nMore abstractly, $\\forall$‚Äôs powers are lifted from the level of picking up vertices to the level of picking up sets of vertices. $\\exists$‚Äôs powers remain unaltered, as compared to the game with imperfect information that was explicated above. It is defined as:\n$$ \\mathcal{SY-PI}(SY) : \\langle N_{PI}, H_{PI}, P_{PI}, U_{PI} \\rangle $$\nThe above mentioned example will be converted to\n Effective Equivalence In this section, we establish that $\\exists$ has a winning strategy in $\\mathcal{SY}(SY)$ iff it has a winning strategy in $\\mathcal{SY-PI}(SY)$. In order to prove this, it will be shown that $\\langle H, \\prec \\rangle$ is isomorphic to $\\langle H_{PI}, \\prec_{PI} \\rangle$ in virtue of the bijection $\\beta$\nThe function $\\beta$ is a map from histories in the perfect information game $\\mathcal{SY-PI}(SY)$ to information cells in the game $\\mathcal{SY}$. To formally define it, $\\beta: H_{PI} \\rightarrow \\wp(H)$.\nFor example, in the above mention $G^X$ we will map $\\beta(\\langle u_*, v_*, u_1 \\rangle)$ where $u_1 = \\{a, b\\}$ to $C_1$ where $C_1 = \\{\\langle u_*, v_* , a\\rangle , \\langle u_*, v_*, b \\rangle \\}$\nJust as a reminder, $C_i$ represents an indistinguishable state for $\\exists$ in $\\mathcal{SY}(SY)$.\nThe perfect information Scotland Yard game was defined in such a way that $\\exists$\u0026rsquo;s imperfect information in $\\mathcal{SY}(SY)$ is propagated to perfect information about sets in $\\mathcal{SY-PI}(SY)$.\nExample of $\\beta$ in lieu of above mentioned example would be:\n It is important to note that though here $\\beta$ is defined to have a codomain $\\wp(H)$, it ends up having a range of $\\mathcal{H}$. This is due to the output always being $C_i$ and $\\mathcal{H} = \\{C_1, C_2 . . C_m \\}$\nTo better define $\\beta$ and actually make it bijective, we redefine it as\n$\\beta: H_{PI} \\rightarrow \\mathcal{H}$\nNow, let\u0026rsquo;s prove that the groups $\\langle H, \\prec \\rangle$ and $\\langle H_{PI}, \\prec_{PI} \\rangle$ are isomorphic.\nIt is proved that $\\beta$ is a bijection between $H_{PI}$ and $\\mathcal{H}$. It remains to be shown that $\\beta$ preserves structure.\nRecall that for $C' \\in \\mathcal{H}$ to be an immediate successor of $C \\in \\mathcal{H}$, there must exist two histories $g, g'$ in $C, C'$ respectively such that $g \\prec g'$ (Proved earlier).\nWhat this proves is that for any histories $h, h' \\in H_{PI}$ it is the case that $h \\prec_{PI} h'$ iff $\\beta(h) \\prec \\beta(h')$\nThe claim is proved by a straightforward inductive argument on the length of the histories in $H_{PI}$\nMaking use of the fact that $\\langle H_{PI}, \\prec_{PI} \\rangle$ and $\\langle H, \\prec \\rangle$ are isomorphic groups, an inductive argument proves that $S$ is a winning strategy for $\\exists$ in $\\mathcal{SY-PI}$ iff $S(\\beta)$ is a winning strategy for $\\exists$ in $\\mathcal{SY}(SY)$.\nüåå PSPACE Let $\\text{SCOTLAND YARD}$ be the set of all Scotland Yard instances such that $\\exists$ has a winning strategy in $\\mathcal{SY}(SY)$.\nIf we are able to prove that there is a winning strategy in PSPACE for $\\mathcal{SY}(SY)$, then it will stand true for $\\mathcal{SY-PI}(SY)$ as well.\nPapadimitriou, namely, observed that deciding the value of a game with perfect information can be done in PSPACE if the following requirements are met:\n The length of any legal sequence of moves is bounded by a polynomial in the size of the input Given a ‚Äúboard position‚Äù of the game there is a polynomial-space algorithm which constructs all possible subsequent actions and board positions; or, if there aren‚Äôt any, decides whether the board position is a win for either player.  $SY‚àíPI(SY)$ meets those condition.\nFor the first point, the length of the description of any history is bounded by the number of rounds $k$, of the game. By assumption, $k \\leq |V|$, thus it is polynomially bounded.\nFor the second point, as we have seen till now, each board game can be represented in form of a decision tree. More formally, if $\\langle h, U, \\overrightarrow{v} \\rangle$ is a non terminal history, then its successors are either (depending on $f$) only $\\langle h, U, \\overrightarrow{v}, \\{w_1 ,. . ., w_m \\} \\rangle$ or all of $\\langle h, U, \\overrightarrow{v}, \\{ w_1 \\} \\rangle$, . . . , $\\langle h, U, \\overrightarrow{v}, \\{ w_m \\} \\rangle$\nWhere $E(U-\\{\\overrightarrow{v}\\}) = \\{ w_1, w_2 , . . , w_m\\}$. These can easily be constructed in PSPACE.\nHENCE PROVED $\\mathcal{SY-PI}(SY)$, AND CONSEQUENTLY, $\\mathcal{SY}(SY)$ ARE PSPACE IN COMPLEXITY.\nNOTE\nIt is later shown that if there were a Scotland yard instance such that each $f = show$, then it would be PSPACE HARD in complexity. Also if each $f = hide$, then it would be NP HARD in complexity. These proofs are omitted due to the complexity of the math involved.\nüìù References   P. Nijssen and M. H. M. Winands, \u0026ldquo;Monte Carlo Tree Search for the Hide-and-Seek Game Scotland Yard,\u0026rdquo; in IEEE Transactions on Computational Intelligence and AI in Games, vol. 4, no. 4, pp. 282-294, Dec. 2012, doi: 10.1109/TCIAIG.2012.2210424.\n  Sevenster, Merlijn. (2006). The complexity of Scotland Yard. Journal of Pharmacology and Experimental Therapeutics - J PHARMACOL EXP THER.\n ","description":"Proving that Scotland Yard is of P-Space complexity.","id":9,"section":"posts","tags":["paper","scotland yard"],"title":"Scotland Yard: Part 2","uri":"https://aurumnpegasus.github.io/website/posts/scotland_yard_2/"},{"content":"Hey, I am Shivansh. I like learning stuff, and I like teaching as well. So, I decided to make this blog, where I will write tutorials about stuff I learn and do. Hopefully, it might end up helping someone one day. The blogs up here will not be restricted to what I study (which varies a lot). It will have posts about literally anything I feel like writing, though I will try to write them professionally.\nFeel free to connect with me on any of the socials provided (ideally via mail üòõ) for feedback or discussion about any topic.\n","description":"Hey, Welcome to my blog","id":10,"section":"","tags":null,"title":"About","uri":"https://aurumnpegasus.github.io/website/about/"}]